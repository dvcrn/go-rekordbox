package rekordbox

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// DjmdRecommendLike represents a row from 'djmdRecommendLike'.
type DjmdRecommendLike struct {
	ID                sql.NullString `json:"ID"`                   // ID
	ContentId1        sql.NullString `json:"ContentID1"`           // ContentID1
	ContentId2        sql.NullString `json:"ContentID2"`           // ContentID2
	LikeRate          sql.NullInt64  `json:"LikeRate"`             // LikeRate
	DataCreatedH      sql.NullInt64  `json:"DataCreatedH"`         // DataCreatedH
	DataCreatedL      sql.NullInt64  `json:"DataCreatedL"`         // DataCreatedL
	UUID              sql.NullString `json:"UUID"`                 // UUID
	RbDataStatus      sql.NullInt64  `json:"rb_data_status"`       // rb_data_status
	RbLocalDataStatus sql.NullInt64  `json:"rb_local_data_status"` // rb_local_data_status
	RbLocalDeleted    sql.NullInt64  `json:"rb_local_deleted"`     // rb_local_deleted
	RbLocalSynced     sql.NullInt64  `json:"rb_local_synced"`      // rb_local_synced
	Usn               sql.NullInt64  `json:"usn"`                  // usn
	RbLocalUsn        sql.NullInt64  `json:"rb_local_usn"`         // rb_local_usn
	CreatedAt         Time           `json:"created_at"`           // created_at
	UpdatedAt         Time           `json:"updated_at"`           // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the DjmdRecommendLike exists in the database.
func (drl *DjmdRecommendLike) Exists() bool {
	return drl._exists
}

// Deleted returns true when the DjmdRecommendLike has been marked for deletion from
// the database.
func (drl *DjmdRecommendLike) Deleted() bool {
	return drl._deleted
}

// Insert inserts the DjmdRecommendLike to the database.
func (c *Client) InsertDjmdRecommendLike(ctx context.Context, drl *DjmdRecommendLike) error {
	db := c.db

	switch {
	case drl._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case drl._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO djmdRecommendLike (` +
		`ID, ContentID1, ContentID2, LikeRate, DataCreatedH, DataCreatedL, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15` +
		`)`
	// run
	logf(sqlstr, drl.ID, drl.ContentId1, drl.ContentId2, drl.LikeRate, drl.DataCreatedH, drl.DataCreatedL, drl.UUID, drl.RbDataStatus, drl.RbLocalDataStatus, drl.RbLocalDeleted, drl.RbLocalSynced, drl.Usn, drl.RbLocalUsn, drl.CreatedAt, drl.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, drl.ID, drl.ContentId1, drl.ContentId2, drl.LikeRate, drl.DataCreatedH, drl.DataCreatedL, drl.UUID, drl.RbDataStatus, drl.RbLocalDataStatus, drl.RbLocalDeleted, drl.RbLocalSynced, drl.Usn, drl.RbLocalUsn, drl.CreatedAt, drl.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	drl._exists = true
	return nil
}

// Update updates a DjmdRecommendLike in the database.
func (c *Client) UpdateDjmdRecommendLike(ctx context.Context, drl *DjmdRecommendLike) error {
	db := c.db

	switch {
	case !drl._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case drl._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE djmdRecommendLike SET ` +
		`ContentID1 = $1, ContentID2 = $2, LikeRate = $3, DataCreatedH = $4, DataCreatedL = $5, UUID = $6, rb_data_status = $7, rb_local_data_status = $8, rb_local_deleted = $9, rb_local_synced = $10, usn = $11, rb_local_usn = $12, created_at = $13, updated_at = $14 ` +
		`WHERE ID = $15`
	// run
	logf(sqlstr, drl.ContentId1, drl.ContentId2, drl.LikeRate, drl.DataCreatedH, drl.DataCreatedL, drl.UUID, drl.RbDataStatus, drl.RbLocalDataStatus, drl.RbLocalDeleted, drl.RbLocalSynced, drl.Usn, drl.RbLocalUsn, drl.CreatedAt, drl.UpdatedAt, drl.ID)
	if _, err := db.ExecContext(ctx, sqlstr, drl.ContentId1, drl.ContentId2, drl.LikeRate, drl.DataCreatedH, drl.DataCreatedL, drl.UUID, drl.RbDataStatus, drl.RbLocalDataStatus, drl.RbLocalDeleted, drl.RbLocalSynced, drl.Usn, drl.RbLocalUsn, drl.CreatedAt, drl.UpdatedAt, drl.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the DjmdRecommendLike to the database.
func (c *Client) SaveDjmdRecommendLike(ctx context.Context, drl *DjmdRecommendLike) error {
	if drl.Exists() {
		return c.UpdateDjmdRecommendLike(ctx, drl)
	}
	return c.InsertDjmdRecommendLike(ctx, drl)
}

// Upsert performs an upsert for DjmdRecommendLike.
func (c *Client) UpsertDjmdRecommendLike(ctx context.Context, drl *DjmdRecommendLike) error {
	db := c.db

	switch {
	case drl._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO djmdRecommendLike (` +
		`ID, ContentID1, ContentID2, LikeRate, DataCreatedH, DataCreatedL, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15` +
		`)` +
		` ON CONFLICT (ID) DO ` +
		`UPDATE SET ` +
		`ContentID1 = EXCLUDED.ContentID1, ContentID2 = EXCLUDED.ContentID2, LikeRate = EXCLUDED.LikeRate, DataCreatedH = EXCLUDED.DataCreatedH, DataCreatedL = EXCLUDED.DataCreatedL, UUID = EXCLUDED.UUID, rb_data_status = EXCLUDED.rb_data_status, rb_local_data_status = EXCLUDED.rb_local_data_status, rb_local_deleted = EXCLUDED.rb_local_deleted, rb_local_synced = EXCLUDED.rb_local_synced, usn = EXCLUDED.usn, rb_local_usn = EXCLUDED.rb_local_usn, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, drl.ID, drl.ContentId1, drl.ContentId2, drl.LikeRate, drl.DataCreatedH, drl.DataCreatedL, drl.UUID, drl.RbDataStatus, drl.RbLocalDataStatus, drl.RbLocalDeleted, drl.RbLocalSynced, drl.Usn, drl.RbLocalUsn, drl.CreatedAt, drl.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, drl.ID, drl.ContentId1, drl.ContentId2, drl.LikeRate, drl.DataCreatedH, drl.DataCreatedL, drl.UUID, drl.RbDataStatus, drl.RbLocalDataStatus, drl.RbLocalDeleted, drl.RbLocalSynced, drl.Usn, drl.RbLocalUsn, drl.CreatedAt, drl.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	drl._exists = true
	return nil
}

// Delete deletes the DjmdRecommendLike from the database.
func (c *Client) DeleteDjmdRecommendLike(ctx context.Context, drl *DjmdRecommendLike) error {
	db := c.db

	switch {
	case !drl._exists: // doesn't exist
		return nil
	case drl._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM djmdRecommendLike ` +
		`WHERE ID = $1`
	// run
	logf(sqlstr, drl.ID)
	if _, err := db.ExecContext(ctx, sqlstr, drl.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	drl._deleted = true
	return nil
}

func scanDjmdRecommendLikeRows(rows *sql.Rows) ([]*DjmdRecommendLike, error) {
	var res []*DjmdRecommendLike
	for rows.Next() {
		drl := DjmdRecommendLike{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&drl.ID, &drl.ContentId1, &drl.ContentId2, &drl.LikeRate, &drl.DataCreatedH, &drl.DataCreatedL, &drl.UUID, &drl.RbDataStatus, &drl.RbLocalDataStatus, &drl.RbLocalDeleted, &drl.RbLocalSynced, &drl.Usn, &drl.RbLocalUsn, &drl.CreatedAt, &drl.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &drl)
	}

	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

func (c *Client) AllDjmdRecommendLike(ctx context.Context) ([]*DjmdRecommendLike, error) {
	db := c.db

	const sqlstr = `SELECT * FROM DjmdRecommendLike`
	rows, err := db.QueryContext(ctx, sqlstr)
	if err != nil {
		return nil, logerror(err)
	}

	defer rows.Close()
	res, err := scanDjmdRecommendLikeRows(rows)
	if err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdRecommendLikeByContentId1ContentId2 retrieves a row from 'djmdRecommendLike' as a DjmdRecommendLike.
//
// Generated from index 'djmd_recommend_like__content_i_d1__content_i_d2'.
func (c *Client) DjmdRecommendLikeByContentId1ContentId2(ctx context.Context, contentId1, contentId2 sql.NullString) ([]*DjmdRecommendLike, error) {
	// func DjmdRecommendLikeByContentId1ContentId2(ctx context.Context, db DB, contentId1 sql.NullString, contentId2 sql.NullString) ([]*DjmdRecommendLike, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID1, ContentID2, LikeRate, DataCreatedH, DataCreatedL, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdRecommendLike ` +
		`WHERE ContentID1 = $1 AND ContentID2 = $2`
	// run
	logf(sqlstr, contentId1, contentId2)
	rows, err := db.QueryContext(ctx, sqlstr, contentId1, contentId2)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdRecommendLike
	for rows.Next() {
		drl := DjmdRecommendLike{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&drl.ID, &drl.ContentId1, &drl.ContentId2, &drl.LikeRate, &drl.DataCreatedH, &drl.DataCreatedL, &drl.UUID, &drl.RbDataStatus, &drl.RbLocalDataStatus, &drl.RbLocalDeleted, &drl.RbLocalSynced, &drl.Usn, &drl.RbLocalUsn, &drl.CreatedAt, &drl.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &drl)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdRecommendLikeByContentId2 retrieves a row from 'djmdRecommendLike' as a DjmdRecommendLike.
//
// Generated from index 'djmd_recommend_like__content_i_d2'.
func (c *Client) DjmdRecommendLikeByContentId2(ctx context.Context, contentId2 sql.NullString) ([]*DjmdRecommendLike, error) {
	// func DjmdRecommendLikeByContentId2(ctx context.Context, db DB, contentId2 sql.NullString) ([]*DjmdRecommendLike, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID1, ContentID2, LikeRate, DataCreatedH, DataCreatedL, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdRecommendLike ` +
		`WHERE ContentID2 = $1`
	// run
	logf(sqlstr, contentId2)
	rows, err := db.QueryContext(ctx, sqlstr, contentId2)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdRecommendLike
	for rows.Next() {
		drl := DjmdRecommendLike{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&drl.ID, &drl.ContentId1, &drl.ContentId2, &drl.LikeRate, &drl.DataCreatedH, &drl.DataCreatedL, &drl.UUID, &drl.RbDataStatus, &drl.RbLocalDataStatus, &drl.RbLocalDeleted, &drl.RbLocalSynced, &drl.Usn, &drl.RbLocalUsn, &drl.CreatedAt, &drl.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &drl)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdRecommendLikeByUUID retrieves a row from 'djmdRecommendLike' as a DjmdRecommendLike.
//
// Generated from index 'djmd_recommend_like__u_u_i_d'.
func (c *Client) DjmdRecommendLikeByUUID(ctx context.Context, uuid sql.NullString) ([]*DjmdRecommendLike, error) {
	// func DjmdRecommendLikeByUUID(ctx context.Context, db DB, uuid sql.NullString) ([]*DjmdRecommendLike, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID1, ContentID2, LikeRate, DataCreatedH, DataCreatedL, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdRecommendLike ` +
		`WHERE UUID = $1`
	// run
	logf(sqlstr, uuid)
	rows, err := db.QueryContext(ctx, sqlstr, uuid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdRecommendLike
	for rows.Next() {
		drl := DjmdRecommendLike{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&drl.ID, &drl.ContentId1, &drl.ContentId2, &drl.LikeRate, &drl.DataCreatedH, &drl.DataCreatedL, &drl.UUID, &drl.RbDataStatus, &drl.RbLocalDataStatus, &drl.RbLocalDeleted, &drl.RbLocalSynced, &drl.Usn, &drl.RbLocalUsn, &drl.CreatedAt, &drl.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &drl)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdRecommendLikeByRbDataStatus retrieves a row from 'djmdRecommendLike' as a DjmdRecommendLike.
//
// Generated from index 'djmd_recommend_like_rb_data_status'.
func (c *Client) DjmdRecommendLikeByRbDataStatus(ctx context.Context, rbDataStatus sql.NullInt64) ([]*DjmdRecommendLike, error) {
	// func DjmdRecommendLikeByRbDataStatus(ctx context.Context, db DB, rbDataStatus sql.NullInt64) ([]*DjmdRecommendLike, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID1, ContentID2, LikeRate, DataCreatedH, DataCreatedL, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdRecommendLike ` +
		`WHERE rb_data_status = $1`
	// run
	logf(sqlstr, rbDataStatus)
	rows, err := db.QueryContext(ctx, sqlstr, rbDataStatus)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdRecommendLike
	for rows.Next() {
		drl := DjmdRecommendLike{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&drl.ID, &drl.ContentId1, &drl.ContentId2, &drl.LikeRate, &drl.DataCreatedH, &drl.DataCreatedL, &drl.UUID, &drl.RbDataStatus, &drl.RbLocalDataStatus, &drl.RbLocalDeleted, &drl.RbLocalSynced, &drl.Usn, &drl.RbLocalUsn, &drl.CreatedAt, &drl.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &drl)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdRecommendLikeByRbLocalDataStatus retrieves a row from 'djmdRecommendLike' as a DjmdRecommendLike.
//
// Generated from index 'djmd_recommend_like_rb_local_data_status'.
func (c *Client) DjmdRecommendLikeByRbLocalDataStatus(ctx context.Context, rbLocalDataStatus sql.NullInt64) ([]*DjmdRecommendLike, error) {
	// func DjmdRecommendLikeByRbLocalDataStatus(ctx context.Context, db DB, rbLocalDataStatus sql.NullInt64) ([]*DjmdRecommendLike, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID1, ContentID2, LikeRate, DataCreatedH, DataCreatedL, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdRecommendLike ` +
		`WHERE rb_local_data_status = $1`
	// run
	logf(sqlstr, rbLocalDataStatus)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDataStatus)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdRecommendLike
	for rows.Next() {
		drl := DjmdRecommendLike{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&drl.ID, &drl.ContentId1, &drl.ContentId2, &drl.LikeRate, &drl.DataCreatedH, &drl.DataCreatedL, &drl.UUID, &drl.RbDataStatus, &drl.RbLocalDataStatus, &drl.RbLocalDeleted, &drl.RbLocalSynced, &drl.Usn, &drl.RbLocalUsn, &drl.CreatedAt, &drl.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &drl)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdRecommendLikeByRbLocalDeleted retrieves a row from 'djmdRecommendLike' as a DjmdRecommendLike.
//
// Generated from index 'djmd_recommend_like_rb_local_deleted'.
func (c *Client) DjmdRecommendLikeByRbLocalDeleted(ctx context.Context, rbLocalDeleted sql.NullInt64) ([]*DjmdRecommendLike, error) {
	// func DjmdRecommendLikeByRbLocalDeleted(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64) ([]*DjmdRecommendLike, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID1, ContentID2, LikeRate, DataCreatedH, DataCreatedL, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdRecommendLike ` +
		`WHERE rb_local_deleted = $1`
	// run
	logf(sqlstr, rbLocalDeleted)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdRecommendLike
	for rows.Next() {
		drl := DjmdRecommendLike{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&drl.ID, &drl.ContentId1, &drl.ContentId2, &drl.LikeRate, &drl.DataCreatedH, &drl.DataCreatedL, &drl.UUID, &drl.RbDataStatus, &drl.RbLocalDataStatus, &drl.RbLocalDeleted, &drl.RbLocalSynced, &drl.Usn, &drl.RbLocalUsn, &drl.CreatedAt, &drl.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &drl)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdRecommendLikeByRbLocalUsnID retrieves a row from 'djmdRecommendLike' as a DjmdRecommendLike.
//
// Generated from index 'djmd_recommend_like_rb_local_usn__i_d'.
func (c *Client) DjmdRecommendLikeByRbLocalUsnID(ctx context.Context, rbLocalUsn sql.NullInt64, id sql.NullString) ([]*DjmdRecommendLike, error) {
	// func DjmdRecommendLikeByRbLocalUsnID(ctx context.Context, db DB, rbLocalUsn sql.NullInt64, id sql.NullString) ([]*DjmdRecommendLike, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID1, ContentID2, LikeRate, DataCreatedH, DataCreatedL, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdRecommendLike ` +
		`WHERE rb_local_usn = $1 AND ID = $2`
	// run
	logf(sqlstr, rbLocalUsn, id)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalUsn, id)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdRecommendLike
	for rows.Next() {
		drl := DjmdRecommendLike{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&drl.ID, &drl.ContentId1, &drl.ContentId2, &drl.LikeRate, &drl.DataCreatedH, &drl.DataCreatedL, &drl.UUID, &drl.RbDataStatus, &drl.RbLocalDataStatus, &drl.RbLocalDeleted, &drl.RbLocalSynced, &drl.Usn, &drl.RbLocalUsn, &drl.CreatedAt, &drl.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &drl)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdRecommendLikeByID retrieves a row from 'djmdRecommendLike' as a DjmdRecommendLike.
//
// Generated from index 'sqlite_autoindex_djmdRecommendLike_1'.
func (c *Client) DjmdRecommendLikeByID(ctx context.Context, id sql.NullString) (*DjmdRecommendLike, error) {
	// func DjmdRecommendLikeByID(ctx context.Context, db DB, id sql.NullString) (*DjmdRecommendLike, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID1, ContentID2, LikeRate, DataCreatedH, DataCreatedL, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdRecommendLike ` +
		`WHERE ID = $1`
	// run
	logf(sqlstr, id)
	drl := DjmdRecommendLike{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&drl.ID, &drl.ContentId1, &drl.ContentId2, &drl.LikeRate, &drl.DataCreatedH, &drl.DataCreatedL, &drl.UUID, &drl.RbDataStatus, &drl.RbLocalDataStatus, &drl.RbLocalDeleted, &drl.RbLocalSynced, &drl.Usn, &drl.RbLocalUsn, &drl.CreatedAt, &drl.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &drl, nil
}
