package rekordbox

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"

	nulltype "github.com/mattn/go-nulltype"
)

// AgentNotificationLog represents a row from 'agentNotificationLog'.
type AgentNotificationLog struct {
	ID               nulltype.NullInt64  `json:"id"`                // ID
	GigyaUID         nulltype.NullString `json:"gigya_uid"`         // gigya_uid
	EventDate        nulltype.NullInt64  `json:"event_date"`        // event_date
	ReportedDatetime *Time               `json:"reported_datetime"` // reported_datetime
	Kind             nulltype.NullInt64  `json:"kind"`              // kind
	Value            nulltype.NullInt64  `json:"value"`             // value
	NotificationID   nulltype.NullInt64  `json:"notification_id"`   // notification_id
	Link             nulltype.NullString `json:"link"`              // link
	CreatedAt        Time                `json:"created_at"`        // created_at
	UpdatedAt        Time                `json:"updated_at"`        // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the AgentNotificationLog exists in the database.
func (anl *AgentNotificationLog) Exists() bool {
	return anl._exists
}

// Deleted returns true when the AgentNotificationLog has been marked for deletion from
// the database.
func (anl *AgentNotificationLog) Deleted() bool {
	return anl._deleted
}

// Insert inserts the AgentNotificationLog to the database.
func (c *Client) InsertAgentNotificationLog(ctx context.Context, anl *AgentNotificationLog) error {
	db := c.db

	switch {
	case anl._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case anl._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO agentNotificationLog (` +
		`ID, gigya_uid, event_date, reported_datetime, kind, value, notification_id, link, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`)`
	// run
	logf(sqlstr, anl.GigyaUID, anl.EventDate, anl.ReportedDatetime, anl.Kind, anl.Value, anl.NotificationID, anl.Link, anl.CreatedAt, anl.UpdatedAt)
	res, err := db.ExecContext(ctx, sqlstr, anl.ID, anl.GigyaUID, anl.EventDate, anl.ReportedDatetime, anl.Kind, anl.Value, anl.NotificationID, anl.Link, anl.CreatedAt, anl.UpdatedAt)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key

	v := nulltype.NullInt64{}
	scanErr := v.Scan(id)
	if scanErr != nil {
		return scanErr
	}

	// anl.ID = nulltype.NullInt64(id)
	anl.ID = v
	// set exists
	anl._exists = true
	return nil
}

// Update updates a AgentNotificationLog in the database.
func (c *Client) UpdateAgentNotificationLog(ctx context.Context, anl *AgentNotificationLog) error {
	db := c.db

	switch {
	case !anl._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case anl._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE agentNotificationLog SET ` +
		`gigya_uid = $1, event_date = $2, reported_datetime = $3, kind = $4, value = $5, notification_id = $6, link = $7, created_at = $8, updated_at = $9 ` +
		`WHERE ID = $10`
	// run
	logf(sqlstr, anl.GigyaUID, anl.EventDate, anl.ReportedDatetime, anl.Kind, anl.Value, anl.NotificationID, anl.Link, anl.CreatedAt, anl.UpdatedAt, anl.ID)
	if _, err := db.ExecContext(ctx, sqlstr, anl.GigyaUID, anl.EventDate, anl.ReportedDatetime, anl.Kind, anl.Value, anl.NotificationID, anl.Link, anl.CreatedAt, anl.UpdatedAt, anl.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the AgentNotificationLog to the database.
func (c *Client) SaveAgentNotificationLog(ctx context.Context, anl *AgentNotificationLog) error {
	if anl.Exists() {
		return c.UpdateAgentNotificationLog(ctx, anl)
	}
	return c.InsertAgentNotificationLog(ctx, anl)
}

// Upsert performs an upsert for AgentNotificationLog.
func (c *Client) UpsertAgentNotificationLog(ctx context.Context, anl *AgentNotificationLog) error {
	db := c.db

	switch {
	case anl._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO agentNotificationLog (` +
		`ID, gigya_uid, event_date, reported_datetime, kind, value, notification_id, link, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`)` +
		` ON CONFLICT (ID) DO ` +
		`UPDATE SET ` +
		`gigya_uid = EXCLUDED.gigya_uid, event_date = EXCLUDED.event_date, reported_datetime = EXCLUDED.reported_datetime, kind = EXCLUDED.kind, value = EXCLUDED.value, notification_id = EXCLUDED.notification_id, link = EXCLUDED.link, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, anl.ID, anl.GigyaUID, anl.EventDate, anl.ReportedDatetime, anl.Kind, anl.Value, anl.NotificationID, anl.Link, anl.CreatedAt, anl.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, anl.ID, anl.GigyaUID, anl.EventDate, anl.ReportedDatetime, anl.Kind, anl.Value, anl.NotificationID, anl.Link, anl.CreatedAt, anl.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	anl._exists = true
	return nil
}

// Delete deletes the AgentNotificationLog from the database.
func (c *Client) DeleteAgentNotificationLog(ctx context.Context, anl *AgentNotificationLog) error {
	db := c.db

	switch {
	case !anl._exists: // doesn't exist
		return nil
	case anl._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM agentNotificationLog ` +
		`WHERE ID = $1`
	// run
	logf(sqlstr, anl.ID)
	if _, err := db.ExecContext(ctx, sqlstr, anl.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	anl._deleted = true
	return nil
}

func scanAgentNotificationLogRows(rows *sql.Rows) ([]*AgentNotificationLog, error) {
	var res []*AgentNotificationLog
	for rows.Next() {
		anl := AgentNotificationLog{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&anl.ID, &anl.GigyaUID, &anl.EventDate, &anl.ReportedDatetime, &anl.Kind, &anl.Value, &anl.NotificationID, &anl.Link, &anl.CreatedAt, &anl.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &anl)
	}

	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

func (c *Client) AllAgentNotificationLog(ctx context.Context) ([]*AgentNotificationLog, error) {
	db := c.db

	const sqlstr = `SELECT * FROM AgentNotificationLog`
	rows, err := db.QueryContext(ctx, sqlstr)
	if err != nil {
		return nil, logerror(err)
	}

	defer rows.Close()
	res, err := scanAgentNotificationLogRows(rows)
	if err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// AgentNotificationLogByID retrieves a row from 'agentNotificationLog' as a AgentNotificationLog.
//
// Generated from index 'agentNotificationLog_ID_pkey'.
func (c *Client) AgentNotificationLogByID(ctx context.Context, id nulltype.NullInt64) (*AgentNotificationLog, error) {
	// func AgentNotificationLogByID(ctx context.Context, db DB, id nulltype.NullInt64) (*AgentNotificationLog, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, gigya_uid, event_date, reported_datetime, kind, value, notification_id, link, created_at, updated_at ` +
		`FROM agentNotificationLog ` +
		`WHERE ID = $1`
	// run
	logf(sqlstr, id)
	anl := AgentNotificationLog{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&anl.ID, &anl.GigyaUID, &anl.EventDate, &anl.ReportedDatetime, &anl.Kind, &anl.Value, &anl.NotificationID, &anl.Link, &anl.CreatedAt, &anl.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &anl, nil
}

// AgentNotificationLogByGigyaUIDEventDateKindNotificationID retrieves a row from 'agentNotificationLog' as a AgentNotificationLog.
//
// Generated from index 'agent_notification_log_gigya_uid_event_date_kind_notification_id'.
func (c *Client) AgentNotificationLogByGigyaUIDEventDateKindNotificationID(ctx context.Context, gigyaUID nulltype.NullString, eventDate, kind, notificationID nulltype.NullInt64) ([]*AgentNotificationLog, error) {
	// func AgentNotificationLogByGigyaUIDEventDateKindNotificationID(ctx context.Context, db DB, gigyaUID nulltype.NullString, eventDate nulltype.NullInt64, kind nulltype.NullInt64, notificationID nulltype.NullInt64) ([]*AgentNotificationLog, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, gigya_uid, event_date, reported_datetime, kind, value, notification_id, link, created_at, updated_at ` +
		`FROM agentNotificationLog ` +
		`WHERE gigya_uid = $1 AND event_date = $2 AND kind = $3 AND notification_id = $4`
	// run
	logf(sqlstr, gigyaUID, eventDate, kind, notificationID)
	rows, err := db.QueryContext(ctx, sqlstr, gigyaUID, eventDate, kind, notificationID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*AgentNotificationLog
	for rows.Next() {
		anl := AgentNotificationLog{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&anl.ID, &anl.GigyaUID, &anl.EventDate, &anl.ReportedDatetime, &anl.Kind, &anl.Value, &anl.NotificationID, &anl.Link, &anl.CreatedAt, &anl.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &anl)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// AgentNotificationLogByReportedDatetimeEventDate retrieves a row from 'agentNotificationLog' as a AgentNotificationLog.
//
// Generated from index 'agent_notification_log_reported_datetime_event_date'.
func (c *Client) AgentNotificationLogByReportedDatetimeEventDate(ctx context.Context, reportedDatetime *Time, eventDate nulltype.NullInt64) ([]*AgentNotificationLog, error) {
	// func AgentNotificationLogByReportedDatetimeEventDate(ctx context.Context, db DB, reportedDatetime *Time, eventDate nulltype.NullInt64) ([]*AgentNotificationLog, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, gigya_uid, event_date, reported_datetime, kind, value, notification_id, link, created_at, updated_at ` +
		`FROM agentNotificationLog ` +
		`WHERE reported_datetime = $1 AND event_date = $2`
	// run
	logf(sqlstr, reportedDatetime, eventDate)
	rows, err := db.QueryContext(ctx, sqlstr, reportedDatetime, eventDate)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*AgentNotificationLog
	for rows.Next() {
		anl := AgentNotificationLog{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&anl.ID, &anl.GigyaUID, &anl.EventDate, &anl.ReportedDatetime, &anl.Kind, &anl.Value, &anl.NotificationID, &anl.Link, &anl.CreatedAt, &anl.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &anl)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
