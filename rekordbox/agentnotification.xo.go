// Package rekordbox contains generated code for schema 'plaintext.db'.
package rekordbox

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"

	nulltype "github.com/mattn/go-nulltype"
)

// AgentNotification represents a row from 'agentNotification'.
type AgentNotification struct {
	ID                    nulltype.NullInt64  `json:"ID"`                      // ID
	GraphicArea           nulltype.NullInt64  `json:"graphic_area"`            // graphic_area
	TextArea              nulltype.NullInt64  `json:"text_area"`               // text_area
	OsNotification        nulltype.NullInt64  `json:"os_notification"`         // os_notification
	StartDatetime         *Time               `json:"start_datetime"`          // start_datetime
	EndDatetime           *Time               `json:"end_datetime"`            // end_datetime
	DisplayDatetime       *Time               `json:"display_datetime"`        // display_datetime
	Interval              nulltype.NullInt64  `json:"interval"`                // interval
	Category              nulltype.NullString `json:"category"`                // category
	CategoryColor         nulltype.NullString `json:"category_color"`          // category_color
	Title                 nulltype.NullString `json:"title"`                   // title
	Description           nulltype.NullString `json:"description"`             // description
	URL                   nulltype.NullString `json:"url"`                     // url
	Image                 nulltype.NullString `json:"image"`                   // image
	ImagePath             nulltype.NullString `json:"image_path"`              // image_path
	ReadStatus            nulltype.NullInt64  `json:"read_status"`             // read_status
	LastDisplayedDatetime *Time               `json:"last_displayed_datetime"` // last_displayed_datetime
	CreatedAt             Time                `json:"created_at"`              // created_at
	UpdatedAt             Time                `json:"updated_at"`              // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the AgentNotification exists in the database.
func (an *AgentNotification) Exists() bool {
	return an._exists
}

// Deleted returns true when the AgentNotification has been marked for deletion from
// the database.
func (an *AgentNotification) Deleted() bool {
	return an._deleted
}

// Insert inserts the AgentNotification to the database.
func (c *Client) InsertAgentNotification(ctx context.Context, an *AgentNotification) error {
	db := c.db

	switch {
	case an._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case an._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO agentNotification (` +
		`ID, graphic_area, text_area, os_notification, start_datetime, end_datetime, display_datetime, interval, category, category_color, title, description, url, image, image_path, read_status, last_displayed_datetime, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19` +
		`)`
	// run
	logf(sqlstr, an.ID, an.GraphicArea, an.TextArea, an.OsNotification, an.StartDatetime, an.EndDatetime, an.DisplayDatetime, an.Interval, an.Category, an.CategoryColor, an.Title, an.Description, an.URL, an.Image, an.ImagePath, an.ReadStatus, an.LastDisplayedDatetime, an.CreatedAt, an.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, an.ID, an.GraphicArea, an.TextArea, an.OsNotification, an.StartDatetime, an.EndDatetime, an.DisplayDatetime, an.Interval, an.Category, an.CategoryColor, an.Title, an.Description, an.URL, an.Image, an.ImagePath, an.ReadStatus, an.LastDisplayedDatetime, an.CreatedAt, an.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	an._exists = true
	return nil
}

// Update updates a AgentNotification in the database.
func (c *Client) UpdateAgentNotification(ctx context.Context, an *AgentNotification) error {
	db := c.db

	switch {
	case !an._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case an._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE agentNotification SET ` +
		`graphic_area = $1, text_area = $2, os_notification = $3, start_datetime = $4, end_datetime = $5, display_datetime = $6, interval = $7, category = $8, category_color = $9, title = $10, description = $11, url = $12, image = $13, image_path = $14, read_status = $15, last_displayed_datetime = $16, created_at = $17, updated_at = $18 ` +
		`WHERE ID = $19`
	// run
	logf(sqlstr, an.GraphicArea, an.TextArea, an.OsNotification, an.StartDatetime, an.EndDatetime, an.DisplayDatetime, an.Interval, an.Category, an.CategoryColor, an.Title, an.Description, an.URL, an.Image, an.ImagePath, an.ReadStatus, an.LastDisplayedDatetime, an.CreatedAt, an.UpdatedAt, an.ID)
	if _, err := db.ExecContext(ctx, sqlstr, an.GraphicArea, an.TextArea, an.OsNotification, an.StartDatetime, an.EndDatetime, an.DisplayDatetime, an.Interval, an.Category, an.CategoryColor, an.Title, an.Description, an.URL, an.Image, an.ImagePath, an.ReadStatus, an.LastDisplayedDatetime, an.CreatedAt, an.UpdatedAt, an.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the AgentNotification to the database.
func (c *Client) SaveAgentNotification(ctx context.Context, an *AgentNotification) error {
	if an.Exists() {
		return c.UpdateAgentNotification(ctx, an)
	}
	return c.InsertAgentNotification(ctx, an)
}

// Upsert performs an upsert for AgentNotification.
func (c *Client) UpsertAgentNotification(ctx context.Context, an *AgentNotification) error {
	db := c.db

	switch {
	case an._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO agentNotification (` +
		`ID, graphic_area, text_area, os_notification, start_datetime, end_datetime, display_datetime, interval, category, category_color, title, description, url, image, image_path, read_status, last_displayed_datetime, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19` +
		`)` +
		` ON CONFLICT (ID) DO ` +
		`UPDATE SET ` +
		`graphic_area = EXCLUDED.graphic_area, text_area = EXCLUDED.text_area, os_notification = EXCLUDED.os_notification, start_datetime = EXCLUDED.start_datetime, end_datetime = EXCLUDED.end_datetime, display_datetime = EXCLUDED.display_datetime, interval = EXCLUDED.interval, category = EXCLUDED.category, category_color = EXCLUDED.category_color, title = EXCLUDED.title, description = EXCLUDED.description, url = EXCLUDED.url, image = EXCLUDED.image, image_path = EXCLUDED.image_path, read_status = EXCLUDED.read_status, last_displayed_datetime = EXCLUDED.last_displayed_datetime, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, an.ID, an.GraphicArea, an.TextArea, an.OsNotification, an.StartDatetime, an.EndDatetime, an.DisplayDatetime, an.Interval, an.Category, an.CategoryColor, an.Title, an.Description, an.URL, an.Image, an.ImagePath, an.ReadStatus, an.LastDisplayedDatetime, an.CreatedAt, an.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, an.ID, an.GraphicArea, an.TextArea, an.OsNotification, an.StartDatetime, an.EndDatetime, an.DisplayDatetime, an.Interval, an.Category, an.CategoryColor, an.Title, an.Description, an.URL, an.Image, an.ImagePath, an.ReadStatus, an.LastDisplayedDatetime, an.CreatedAt, an.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	an._exists = true
	return nil
}

// Delete deletes the AgentNotification from the database.
func (c *Client) DeleteAgentNotification(ctx context.Context, an *AgentNotification) error {
	db := c.db

	switch {
	case !an._exists: // doesn't exist
		return nil
	case an._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM agentNotification ` +
		`WHERE ID = $1`
	// run
	logf(sqlstr, an.ID)
	if _, err := db.ExecContext(ctx, sqlstr, an.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	an._deleted = true
	return nil
}

func scanAgentNotificationRows(rows *sql.Rows) ([]*AgentNotification, error) {
	var res []*AgentNotification
	for rows.Next() {
		an := AgentNotification{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&an.ID, &an.GraphicArea, &an.TextArea, &an.OsNotification, &an.StartDatetime, &an.EndDatetime, &an.DisplayDatetime, &an.Interval, &an.Category, &an.CategoryColor, &an.Title, &an.Description, &an.URL, &an.Image, &an.ImagePath, &an.ReadStatus, &an.LastDisplayedDatetime, &an.CreatedAt, &an.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &an)
	}

	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

func (c *Client) AllAgentNotification(ctx context.Context) ([]*AgentNotification, error) {
	db := c.db

	const sqlstr = `SELECT * FROM AgentNotification`
	rows, err := db.QueryContext(ctx, sqlstr)
	if err != nil {
		return nil, logerror(err)
	}

	defer rows.Close()
	res, err := scanAgentNotificationRows(rows)
	if err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// AgentNotificationByStartDatetimeEndDatetime retrieves a row from 'agentNotification' as a AgentNotification.
//
// Generated from index 'agent_notification_start_datetime_end_datetime'.
func (c *Client) AgentNotificationByStartDatetimeEndDatetime(ctx context.Context, startDatetime, endDatetime *Time) ([]*AgentNotification, error) {
	// func AgentNotificationByStartDatetimeEndDatetime(ctx context.Context, db DB, startDatetime *Time, endDatetime *Time) ([]*AgentNotification, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, graphic_area, text_area, os_notification, start_datetime, end_datetime, display_datetime, interval, category, category_color, title, description, url, image, image_path, read_status, last_displayed_datetime, created_at, updated_at ` +
		`FROM agentNotification ` +
		`WHERE start_datetime = $1 AND end_datetime = $2`
	// run
	logf(sqlstr, startDatetime, endDatetime)
	rows, err := db.QueryContext(ctx, sqlstr, startDatetime, endDatetime)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*AgentNotification
	for rows.Next() {
		an := AgentNotification{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&an.ID, &an.GraphicArea, &an.TextArea, &an.OsNotification, &an.StartDatetime, &an.EndDatetime, &an.DisplayDatetime, &an.Interval, &an.Category, &an.CategoryColor, &an.Title, &an.Description, &an.URL, &an.Image, &an.ImagePath, &an.ReadStatus, &an.LastDisplayedDatetime, &an.CreatedAt, &an.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &an)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// AgentNotificationByID retrieves a row from 'agentNotification' as a AgentNotification.
//
// Generated from index 'sqlite_autoindex_agentNotification_1'.
func (c *Client) AgentNotificationByID(ctx context.Context, id nulltype.NullInt64) (*AgentNotification, error) {
	// func AgentNotificationByID(ctx context.Context, db DB, id nulltype.NullInt64) (*AgentNotification, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, graphic_area, text_area, os_notification, start_datetime, end_datetime, display_datetime, interval, category, category_color, title, description, url, image, image_path, read_status, last_displayed_datetime, created_at, updated_at ` +
		`FROM agentNotification ` +
		`WHERE ID = $1`
	// run
	logf(sqlstr, id)
	an := AgentNotification{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&an.ID, &an.GraphicArea, &an.TextArea, &an.OsNotification, &an.StartDatetime, &an.EndDatetime, &an.DisplayDatetime, &an.Interval, &an.Category, &an.CategoryColor, &an.Title, &an.Description, &an.URL, &an.Image, &an.ImagePath, &an.ReadStatus, &an.LastDisplayedDatetime, &an.CreatedAt, &an.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &an, nil
}
