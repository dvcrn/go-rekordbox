package rekordbox

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// DjmdCue represents a row from 'djmdCue'.
type DjmdCue struct {
	ID                sql.NullString `json:"ID"`                   // ID
	ContentID         sql.NullString `json:"ContentID"`            // ContentID
	InMsec            sql.NullInt64  `json:"InMsec"`               // InMsec
	InFrame           sql.NullInt64  `json:"InFrame"`              // InFrame
	InMpegFrame       sql.NullInt64  `json:"InMpegFrame"`          // InMpegFrame
	InMpegAbs         sql.NullInt64  `json:"InMpegAbs"`            // InMpegAbs
	OutMsec           sql.NullInt64  `json:"OutMsec"`              // OutMsec
	OutFrame          sql.NullInt64  `json:"OutFrame"`             // OutFrame
	OutMpegFrame      sql.NullInt64  `json:"OutMpegFrame"`         // OutMpegFrame
	OutMpegAbs        sql.NullInt64  `json:"OutMpegAbs"`           // OutMpegAbs
	Kind              sql.NullInt64  `json:"Kind"`                 // Kind
	Color             sql.NullInt64  `json:"Color"`                // Color
	ColorTableIndex   sql.NullInt64  `json:"ColorTableIndex"`      // ColorTableIndex
	ActiveLoop        sql.NullInt64  `json:"ActiveLoop"`           // ActiveLoop
	Comment           sql.NullString `json:"Comment"`              // Comment
	BeatLoopSize      sql.NullInt64  `json:"BeatLoopSize"`         // BeatLoopSize
	CueMicrosec       sql.NullInt64  `json:"CueMicrosec"`          // CueMicrosec
	InPointSeekInfo   sql.NullString `json:"InPointSeekInfo"`      // InPointSeekInfo
	OutPointSeekInfo  sql.NullString `json:"OutPointSeekInfo"`     // OutPointSeekInfo
	ContentUUID       sql.NullString `json:"ContentUUID"`          // ContentUUID
	UUID              sql.NullString `json:"UUID"`                 // UUID
	RbDataStatus      sql.NullInt64  `json:"rb_data_status"`       // rb_data_status
	RbLocalDataStatus sql.NullInt64  `json:"rb_local_data_status"` // rb_local_data_status
	RbLocalDeleted    sql.NullInt64  `json:"rb_local_deleted"`     // rb_local_deleted
	RbLocalSynced     sql.NullInt64  `json:"rb_local_synced"`      // rb_local_synced
	Usn               sql.NullInt64  `json:"usn"`                  // usn
	RbLocalUsn        sql.NullInt64  `json:"rb_local_usn"`         // rb_local_usn
	CreatedAt         Time           `json:"created_at"`           // created_at
	UpdatedAt         Time           `json:"updated_at"`           // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the DjmdCue exists in the database.
func (dc *DjmdCue) Exists() bool {
	return dc._exists
}

// Deleted returns true when the DjmdCue has been marked for deletion from
// the database.
func (dc *DjmdCue) Deleted() bool {
	return dc._deleted
}

// Insert inserts the DjmdCue to the database.
func (c *Client) InsertDjmdCue(ctx context.Context, dc *DjmdCue) error {
	db := c.db

	switch {
	case dc._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case dc._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO djmdCue (` +
		`ID, ContentID, InMsec, InFrame, InMpegFrame, InMpegAbs, OutMsec, OutFrame, OutMpegFrame, OutMpegAbs, Kind, Color, ColorTableIndex, ActiveLoop, Comment, BeatLoopSize, CueMicrosec, InPointSeekInfo, OutPointSeekInfo, ContentUUID, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29` +
		`)`
	// run
	logf(sqlstr, dc.ID, dc.ContentID, dc.InMsec, dc.InFrame, dc.InMpegFrame, dc.InMpegAbs, dc.OutMsec, dc.OutFrame, dc.OutMpegFrame, dc.OutMpegAbs, dc.Kind, dc.Color, dc.ColorTableIndex, dc.ActiveLoop, dc.Comment, dc.BeatLoopSize, dc.CueMicrosec, dc.InPointSeekInfo, dc.OutPointSeekInfo, dc.ContentUUID, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, dc.ID, dc.ContentID, dc.InMsec, dc.InFrame, dc.InMpegFrame, dc.InMpegAbs, dc.OutMsec, dc.OutFrame, dc.OutMpegFrame, dc.OutMpegAbs, dc.Kind, dc.Color, dc.ColorTableIndex, dc.ActiveLoop, dc.Comment, dc.BeatLoopSize, dc.CueMicrosec, dc.InPointSeekInfo, dc.OutPointSeekInfo, dc.ContentUUID, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	dc._exists = true
	return nil
}

// Update updates a DjmdCue in the database.
func (c *Client) UpdateDjmdCue(ctx context.Context, dc *DjmdCue) error {
	db := c.db

	switch {
	case !dc._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case dc._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE djmdCue SET ` +
		`ContentID = $1, InMsec = $2, InFrame = $3, InMpegFrame = $4, InMpegAbs = $5, OutMsec = $6, OutFrame = $7, OutMpegFrame = $8, OutMpegAbs = $9, Kind = $10, Color = $11, ColorTableIndex = $12, ActiveLoop = $13, Comment = $14, BeatLoopSize = $15, CueMicrosec = $16, InPointSeekInfo = $17, OutPointSeekInfo = $18, ContentUUID = $19, UUID = $20, rb_data_status = $21, rb_local_data_status = $22, rb_local_deleted = $23, rb_local_synced = $24, usn = $25, rb_local_usn = $26, created_at = $27, updated_at = $28 ` +
		`WHERE ID = $29`
	// run
	logf(sqlstr, dc.ContentID, dc.InMsec, dc.InFrame, dc.InMpegFrame, dc.InMpegAbs, dc.OutMsec, dc.OutFrame, dc.OutMpegFrame, dc.OutMpegAbs, dc.Kind, dc.Color, dc.ColorTableIndex, dc.ActiveLoop, dc.Comment, dc.BeatLoopSize, dc.CueMicrosec, dc.InPointSeekInfo, dc.OutPointSeekInfo, dc.ContentUUID, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt, dc.ID)
	if _, err := db.ExecContext(ctx, sqlstr, dc.ContentID, dc.InMsec, dc.InFrame, dc.InMpegFrame, dc.InMpegAbs, dc.OutMsec, dc.OutFrame, dc.OutMpegFrame, dc.OutMpegAbs, dc.Kind, dc.Color, dc.ColorTableIndex, dc.ActiveLoop, dc.Comment, dc.BeatLoopSize, dc.CueMicrosec, dc.InPointSeekInfo, dc.OutPointSeekInfo, dc.ContentUUID, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt, dc.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the DjmdCue to the database.
func (c *Client) SaveDjmdCue(ctx context.Context, dc *DjmdCue) error {
	if dc.Exists() {
		return c.UpdateDjmdCue(ctx, dc)
	}
	return c.InsertDjmdCue(ctx, dc)
}

// Upsert performs an upsert for DjmdCue.
func (c *Client) UpsertDjmdCue(ctx context.Context, dc *DjmdCue) error {
	db := c.db

	switch {
	case dc._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO djmdCue (` +
		`ID, ContentID, InMsec, InFrame, InMpegFrame, InMpegAbs, OutMsec, OutFrame, OutMpegFrame, OutMpegAbs, Kind, Color, ColorTableIndex, ActiveLoop, Comment, BeatLoopSize, CueMicrosec, InPointSeekInfo, OutPointSeekInfo, ContentUUID, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29` +
		`)` +
		` ON CONFLICT (ID) DO ` +
		`UPDATE SET ` +
		`ContentID = EXCLUDED.ContentID, InMsec = EXCLUDED.InMsec, InFrame = EXCLUDED.InFrame, InMpegFrame = EXCLUDED.InMpegFrame, InMpegAbs = EXCLUDED.InMpegAbs, OutMsec = EXCLUDED.OutMsec, OutFrame = EXCLUDED.OutFrame, OutMpegFrame = EXCLUDED.OutMpegFrame, OutMpegAbs = EXCLUDED.OutMpegAbs, Kind = EXCLUDED.Kind, Color = EXCLUDED.Color, ColorTableIndex = EXCLUDED.ColorTableIndex, ActiveLoop = EXCLUDED.ActiveLoop, Comment = EXCLUDED.Comment, BeatLoopSize = EXCLUDED.BeatLoopSize, CueMicrosec = EXCLUDED.CueMicrosec, InPointSeekInfo = EXCLUDED.InPointSeekInfo, OutPointSeekInfo = EXCLUDED.OutPointSeekInfo, ContentUUID = EXCLUDED.ContentUUID, UUID = EXCLUDED.UUID, rb_data_status = EXCLUDED.rb_data_status, rb_local_data_status = EXCLUDED.rb_local_data_status, rb_local_deleted = EXCLUDED.rb_local_deleted, rb_local_synced = EXCLUDED.rb_local_synced, usn = EXCLUDED.usn, rb_local_usn = EXCLUDED.rb_local_usn, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, dc.ID, dc.ContentID, dc.InMsec, dc.InFrame, dc.InMpegFrame, dc.InMpegAbs, dc.OutMsec, dc.OutFrame, dc.OutMpegFrame, dc.OutMpegAbs, dc.Kind, dc.Color, dc.ColorTableIndex, dc.ActiveLoop, dc.Comment, dc.BeatLoopSize, dc.CueMicrosec, dc.InPointSeekInfo, dc.OutPointSeekInfo, dc.ContentUUID, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, dc.ID, dc.ContentID, dc.InMsec, dc.InFrame, dc.InMpegFrame, dc.InMpegAbs, dc.OutMsec, dc.OutFrame, dc.OutMpegFrame, dc.OutMpegAbs, dc.Kind, dc.Color, dc.ColorTableIndex, dc.ActiveLoop, dc.Comment, dc.BeatLoopSize, dc.CueMicrosec, dc.InPointSeekInfo, dc.OutPointSeekInfo, dc.ContentUUID, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	dc._exists = true
	return nil
}

// Delete deletes the DjmdCue from the database.
func (c *Client) DeleteDjmdCue(ctx context.Context, dc *DjmdCue) error {
	db := c.db

	switch {
	case !dc._exists: // doesn't exist
		return nil
	case dc._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM djmdCue ` +
		`WHERE ID = $1`
	// run
	logf(sqlstr, dc.ID)
	if _, err := db.ExecContext(ctx, sqlstr, dc.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	dc._deleted = true
	return nil
}

func scanDjmdCueRows(rows *sql.Rows) ([]*DjmdCue, error) {
	var res []*DjmdCue
	for rows.Next() {
		dc := DjmdCue{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.ContentID, &dc.InMsec, &dc.InFrame, &dc.InMpegFrame, &dc.InMpegAbs, &dc.OutMsec, &dc.OutFrame, &dc.OutMpegFrame, &dc.OutMpegAbs, &dc.Kind, &dc.Color, &dc.ColorTableIndex, &dc.ActiveLoop, &dc.Comment, &dc.BeatLoopSize, &dc.CueMicrosec, &dc.InPointSeekInfo, &dc.OutPointSeekInfo, &dc.ContentUUID, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}

	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

func (c *Client) AllDjmdCue(ctx context.Context) ([]*DjmdCue, error) {
	db := c.db

	const sqlstr = `SELECT * FROM DjmdCue`
	rows, err := db.QueryContext(ctx, sqlstr)
	if err != nil {
		return nil, logerror(err)
	}

	defer rows.Close()
	res, err := scanDjmdCueRows(rows)
	if err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdCueByContentID retrieves a row from 'djmdCue' as a DjmdCue.
//
// Generated from index 'djmd_cue__content_i_d'.
func (c *Client) DjmdCueByContentID(ctx context.Context, contentID sql.NullString) ([]*DjmdCue, error) {
	// func DjmdCueByContentID(ctx context.Context, db DB, contentID sql.NullString) ([]*DjmdCue, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID, InMsec, InFrame, InMpegFrame, InMpegAbs, OutMsec, OutFrame, OutMpegFrame, OutMpegAbs, Kind, Color, ColorTableIndex, ActiveLoop, Comment, BeatLoopSize, CueMicrosec, InPointSeekInfo, OutPointSeekInfo, ContentUUID, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdCue ` +
		`WHERE ContentID = $1`
	// run
	logf(sqlstr, contentID)
	rows, err := db.QueryContext(ctx, sqlstr, contentID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdCue
	for rows.Next() {
		dc := DjmdCue{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.ContentID, &dc.InMsec, &dc.InFrame, &dc.InMpegFrame, &dc.InMpegAbs, &dc.OutMsec, &dc.OutFrame, &dc.OutMpegFrame, &dc.OutMpegAbs, &dc.Kind, &dc.Color, &dc.ColorTableIndex, &dc.ActiveLoop, &dc.Comment, &dc.BeatLoopSize, &dc.CueMicrosec, &dc.InPointSeekInfo, &dc.OutPointSeekInfo, &dc.ContentUUID, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdCueByContentIDRbLocalDeleted retrieves a row from 'djmdCue' as a DjmdCue.
//
// Generated from index 'djmd_cue__content_i_d_rb_local_deleted'.
func (c *Client) DjmdCueByContentIDRbLocalDeleted(ctx context.Context, contentID sql.NullString, rbLocalDeleted sql.NullInt64) ([]*DjmdCue, error) {
	// func DjmdCueByContentIDRbLocalDeleted(ctx context.Context, db DB, contentID sql.NullString, rbLocalDeleted sql.NullInt64) ([]*DjmdCue, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID, InMsec, InFrame, InMpegFrame, InMpegAbs, OutMsec, OutFrame, OutMpegFrame, OutMpegAbs, Kind, Color, ColorTableIndex, ActiveLoop, Comment, BeatLoopSize, CueMicrosec, InPointSeekInfo, OutPointSeekInfo, ContentUUID, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdCue ` +
		`WHERE ContentID = $1 AND rb_local_deleted = $2`
	// run
	logf(sqlstr, contentID, rbLocalDeleted)
	rows, err := db.QueryContext(ctx, sqlstr, contentID, rbLocalDeleted)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdCue
	for rows.Next() {
		dc := DjmdCue{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.ContentID, &dc.InMsec, &dc.InFrame, &dc.InMpegFrame, &dc.InMpegAbs, &dc.OutMsec, &dc.OutFrame, &dc.OutMpegFrame, &dc.OutMpegAbs, &dc.Kind, &dc.Color, &dc.ColorTableIndex, &dc.ActiveLoop, &dc.Comment, &dc.BeatLoopSize, &dc.CueMicrosec, &dc.InPointSeekInfo, &dc.OutPointSeekInfo, &dc.ContentUUID, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdCueByContentUUID retrieves a row from 'djmdCue' as a DjmdCue.
//
// Generated from index 'djmd_cue__content_u_u_i_d'.
func (c *Client) DjmdCueByContentUUID(ctx context.Context, contentUUID sql.NullString) ([]*DjmdCue, error) {
	// func DjmdCueByContentUUID(ctx context.Context, db DB, contentUUID sql.NullString) ([]*DjmdCue, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID, InMsec, InFrame, InMpegFrame, InMpegAbs, OutMsec, OutFrame, OutMpegFrame, OutMpegAbs, Kind, Color, ColorTableIndex, ActiveLoop, Comment, BeatLoopSize, CueMicrosec, InPointSeekInfo, OutPointSeekInfo, ContentUUID, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdCue ` +
		`WHERE ContentUUID = $1`
	// run
	logf(sqlstr, contentUUID)
	rows, err := db.QueryContext(ctx, sqlstr, contentUUID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdCue
	for rows.Next() {
		dc := DjmdCue{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.ContentID, &dc.InMsec, &dc.InFrame, &dc.InMpegFrame, &dc.InMpegAbs, &dc.OutMsec, &dc.OutFrame, &dc.OutMpegFrame, &dc.OutMpegAbs, &dc.Kind, &dc.Color, &dc.ColorTableIndex, &dc.ActiveLoop, &dc.Comment, &dc.BeatLoopSize, &dc.CueMicrosec, &dc.InPointSeekInfo, &dc.OutPointSeekInfo, &dc.ContentUUID, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdCueByUUID retrieves a row from 'djmdCue' as a DjmdCue.
//
// Generated from index 'djmd_cue__u_u_i_d'.
func (c *Client) DjmdCueByUUID(ctx context.Context, uuid sql.NullString) ([]*DjmdCue, error) {
	// func DjmdCueByUUID(ctx context.Context, db DB, uuid sql.NullString) ([]*DjmdCue, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID, InMsec, InFrame, InMpegFrame, InMpegAbs, OutMsec, OutFrame, OutMpegFrame, OutMpegAbs, Kind, Color, ColorTableIndex, ActiveLoop, Comment, BeatLoopSize, CueMicrosec, InPointSeekInfo, OutPointSeekInfo, ContentUUID, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdCue ` +
		`WHERE UUID = $1`
	// run
	logf(sqlstr, uuid)
	rows, err := db.QueryContext(ctx, sqlstr, uuid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdCue
	for rows.Next() {
		dc := DjmdCue{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.ContentID, &dc.InMsec, &dc.InFrame, &dc.InMpegFrame, &dc.InMpegAbs, &dc.OutMsec, &dc.OutFrame, &dc.OutMpegFrame, &dc.OutMpegAbs, &dc.Kind, &dc.Color, &dc.ColorTableIndex, &dc.ActiveLoop, &dc.Comment, &dc.BeatLoopSize, &dc.CueMicrosec, &dc.InPointSeekInfo, &dc.OutPointSeekInfo, &dc.ContentUUID, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdCueByRbDataStatus retrieves a row from 'djmdCue' as a DjmdCue.
//
// Generated from index 'djmd_cue_rb_data_status'.
func (c *Client) DjmdCueByRbDataStatus(ctx context.Context, rbDataStatus sql.NullInt64) ([]*DjmdCue, error) {
	// func DjmdCueByRbDataStatus(ctx context.Context, db DB, rbDataStatus sql.NullInt64) ([]*DjmdCue, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID, InMsec, InFrame, InMpegFrame, InMpegAbs, OutMsec, OutFrame, OutMpegFrame, OutMpegAbs, Kind, Color, ColorTableIndex, ActiveLoop, Comment, BeatLoopSize, CueMicrosec, InPointSeekInfo, OutPointSeekInfo, ContentUUID, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdCue ` +
		`WHERE rb_data_status = $1`
	// run
	logf(sqlstr, rbDataStatus)
	rows, err := db.QueryContext(ctx, sqlstr, rbDataStatus)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdCue
	for rows.Next() {
		dc := DjmdCue{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.ContentID, &dc.InMsec, &dc.InFrame, &dc.InMpegFrame, &dc.InMpegAbs, &dc.OutMsec, &dc.OutFrame, &dc.OutMpegFrame, &dc.OutMpegAbs, &dc.Kind, &dc.Color, &dc.ColorTableIndex, &dc.ActiveLoop, &dc.Comment, &dc.BeatLoopSize, &dc.CueMicrosec, &dc.InPointSeekInfo, &dc.OutPointSeekInfo, &dc.ContentUUID, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdCueByRbLocalDataStatus retrieves a row from 'djmdCue' as a DjmdCue.
//
// Generated from index 'djmd_cue_rb_local_data_status'.
func (c *Client) DjmdCueByRbLocalDataStatus(ctx context.Context, rbLocalDataStatus sql.NullInt64) ([]*DjmdCue, error) {
	// func DjmdCueByRbLocalDataStatus(ctx context.Context, db DB, rbLocalDataStatus sql.NullInt64) ([]*DjmdCue, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID, InMsec, InFrame, InMpegFrame, InMpegAbs, OutMsec, OutFrame, OutMpegFrame, OutMpegAbs, Kind, Color, ColorTableIndex, ActiveLoop, Comment, BeatLoopSize, CueMicrosec, InPointSeekInfo, OutPointSeekInfo, ContentUUID, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdCue ` +
		`WHERE rb_local_data_status = $1`
	// run
	logf(sqlstr, rbLocalDataStatus)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDataStatus)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdCue
	for rows.Next() {
		dc := DjmdCue{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.ContentID, &dc.InMsec, &dc.InFrame, &dc.InMpegFrame, &dc.InMpegAbs, &dc.OutMsec, &dc.OutFrame, &dc.OutMpegFrame, &dc.OutMpegAbs, &dc.Kind, &dc.Color, &dc.ColorTableIndex, &dc.ActiveLoop, &dc.Comment, &dc.BeatLoopSize, &dc.CueMicrosec, &dc.InPointSeekInfo, &dc.OutPointSeekInfo, &dc.ContentUUID, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdCueByRbLocalDeleted retrieves a row from 'djmdCue' as a DjmdCue.
//
// Generated from index 'djmd_cue_rb_local_deleted'.
func (c *Client) DjmdCueByRbLocalDeleted(ctx context.Context, rbLocalDeleted sql.NullInt64) ([]*DjmdCue, error) {
	// func DjmdCueByRbLocalDeleted(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64) ([]*DjmdCue, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID, InMsec, InFrame, InMpegFrame, InMpegAbs, OutMsec, OutFrame, OutMpegFrame, OutMpegAbs, Kind, Color, ColorTableIndex, ActiveLoop, Comment, BeatLoopSize, CueMicrosec, InPointSeekInfo, OutPointSeekInfo, ContentUUID, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdCue ` +
		`WHERE rb_local_deleted = $1`
	// run
	logf(sqlstr, rbLocalDeleted)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdCue
	for rows.Next() {
		dc := DjmdCue{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.ContentID, &dc.InMsec, &dc.InFrame, &dc.InMpegFrame, &dc.InMpegAbs, &dc.OutMsec, &dc.OutFrame, &dc.OutMpegFrame, &dc.OutMpegAbs, &dc.Kind, &dc.Color, &dc.ColorTableIndex, &dc.ActiveLoop, &dc.Comment, &dc.BeatLoopSize, &dc.CueMicrosec, &dc.InPointSeekInfo, &dc.OutPointSeekInfo, &dc.ContentUUID, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdCueByRbLocalUsnID retrieves a row from 'djmdCue' as a DjmdCue.
//
// Generated from index 'djmd_cue_rb_local_usn__i_d'.
func (c *Client) DjmdCueByRbLocalUsnID(ctx context.Context, rbLocalUsn sql.NullInt64, id sql.NullString) ([]*DjmdCue, error) {
	// func DjmdCueByRbLocalUsnID(ctx context.Context, db DB, rbLocalUsn sql.NullInt64, id sql.NullString) ([]*DjmdCue, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID, InMsec, InFrame, InMpegFrame, InMpegAbs, OutMsec, OutFrame, OutMpegFrame, OutMpegAbs, Kind, Color, ColorTableIndex, ActiveLoop, Comment, BeatLoopSize, CueMicrosec, InPointSeekInfo, OutPointSeekInfo, ContentUUID, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdCue ` +
		`WHERE rb_local_usn = $1 AND ID = $2`
	// run
	logf(sqlstr, rbLocalUsn, id)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalUsn, id)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdCue
	for rows.Next() {
		dc := DjmdCue{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.ContentID, &dc.InMsec, &dc.InFrame, &dc.InMpegFrame, &dc.InMpegAbs, &dc.OutMsec, &dc.OutFrame, &dc.OutMpegFrame, &dc.OutMpegAbs, &dc.Kind, &dc.Color, &dc.ColorTableIndex, &dc.ActiveLoop, &dc.Comment, &dc.BeatLoopSize, &dc.CueMicrosec, &dc.InPointSeekInfo, &dc.OutPointSeekInfo, &dc.ContentUUID, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdCueByID retrieves a row from 'djmdCue' as a DjmdCue.
//
// Generated from index 'sqlite_autoindex_djmdCue_1'.
func (c *Client) DjmdCueByID(ctx context.Context, id sql.NullString) (*DjmdCue, error) {
	// func DjmdCueByID(ctx context.Context, db DB, id sql.NullString) (*DjmdCue, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, ContentID, InMsec, InFrame, InMpegFrame, InMpegAbs, OutMsec, OutFrame, OutMpegFrame, OutMpegAbs, Kind, Color, ColorTableIndex, ActiveLoop, Comment, BeatLoopSize, CueMicrosec, InPointSeekInfo, OutPointSeekInfo, ContentUUID, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdCue ` +
		`WHERE ID = $1`
	// run
	logf(sqlstr, id)
	dc := DjmdCue{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&dc.ID, &dc.ContentID, &dc.InMsec, &dc.InFrame, &dc.InMpegFrame, &dc.InMpegAbs, &dc.OutMsec, &dc.OutFrame, &dc.OutMpegFrame, &dc.OutMpegAbs, &dc.Kind, &dc.Color, &dc.ColorTableIndex, &dc.ActiveLoop, &dc.Comment, &dc.BeatLoopSize, &dc.CueMicrosec, &dc.InPointSeekInfo, &dc.OutPointSeekInfo, &dc.ContentUUID, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &dc, nil
}
