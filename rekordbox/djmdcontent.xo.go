package rekordbox

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"

	nulltype "github.com/mattn/go-nulltype"
)

// DjmdContent represents a row from 'djmdContent'.
type DjmdContent struct {
	ID                nulltype.NullString  `json:"id"`                   // ID
	FolderPath        nulltype.NullString  `json:"folder_path"`          // FolderPath
	FileNameL         nulltype.NullString  `json:"file_name_l"`          // FileNameL
	FileNameS         nulltype.NullString  `json:"file_name_s"`          // FileNameS
	Title             nulltype.NullString  `json:"title"`                // Title
	ArtistID          nulltype.NullString  `json:"artist_id"`            // ArtistID
	AlbumID           nulltype.NullString  `json:"album_id"`             // AlbumID
	GenreID           nulltype.NullString  `json:"genre_id"`             // GenreID
	BPM               nulltype.NullInt64   `json:"bpm"`                  // BPM
	Length            nulltype.NullInt64   `json:"length"`               // Length
	TrackNo           nulltype.NullInt64   `json:"track_no"`             // TrackNo
	BitRate           nulltype.NullInt64   `json:"bit_rate"`             // BitRate
	BitDepth          nulltype.NullInt64   `json:"bit_depth"`            // BitDepth
	Commnt            nulltype.NullString  `json:"commnt"`               // Commnt
	FileType          nulltype.NullInt64   `json:"file_type"`            // FileType
	Rating            nulltype.NullInt64   `json:"rating"`               // Rating
	ReleaseYear       nulltype.NullInt64   `json:"release_year"`         // ReleaseYear
	RemixerID         nulltype.NullString  `json:"remixer_id"`           // RemixerID
	LabelID           nulltype.NullString  `json:"label_id"`             // LabelID
	OrgArtistID       nulltype.NullString  `json:"org_artist_id"`        // OrgArtistID
	KeyID             nulltype.NullString  `json:"key_id"`               // KeyID
	StockDate         nulltype.NullString  `json:"stock_date"`           // StockDate
	ColorID           nulltype.NullString  `json:"color_id"`             // ColorID
	DJPlayCount       nulltype.NullInt64   `json:"dj_play_count"`        // DJPlayCount
	ImagePath         nulltype.NullString  `json:"image_path"`           // ImagePath
	MasterDBID        nulltype.NullString  `json:"master_dbid"`          // MasterDBID
	MasterSongID      nulltype.NullString  `json:"master_song_id"`       // MasterSongID
	AnalysisDataPath  nulltype.NullString  `json:"analysis_data_path"`   // AnalysisDataPath
	SearchStr         nulltype.NullString  `json:"search_str"`           // SearchStr
	FileSize          nulltype.NullInt64   `json:"file_size"`            // FileSize
	DiscNo            nulltype.NullInt64   `json:"disc_no"`              // DiscNo
	ComposerID        nulltype.NullString  `json:"composer_id"`          // ComposerID
	Subtitle          nulltype.NullString  `json:"subtitle"`             // Subtitle
	SampleRate        nulltype.NullInt64   `json:"sample_rate"`          // SampleRate
	DisableQuantize   nulltype.NullInt64   `json:"disable_quantize"`     // DisableQuantize
	Analysed          nulltype.NullInt64   `json:"analysed"`             // Analysed
	ReleaseDate       nulltype.NullString  `json:"release_date"`         // ReleaseDate
	DateCreated       nulltype.NullString  `json:"date_created"`         // DateCreated
	ContentLink       nulltype.NullInt64   `json:"content_link"`         // ContentLink
	Tag               nulltype.NullString  `json:"tag"`                  // Tag
	ModifiedByRBM     nulltype.NullString  `json:"modified_by_rbm"`      // ModifiedByRBM
	HotCueAutoLoad    nulltype.NullString  `json:"hot_cue_auto_load"`    // HotCueAutoLoad
	DeliveryControl   nulltype.NullString  `json:"delivery_control"`     // DeliveryControl
	DeliveryComment   nulltype.NullString  `json:"delivery_comment"`     // DeliveryComment
	CueUpdated        nulltype.NullString  `json:"cue_updated"`          // CueUpdated
	AnalysisUpdated   nulltype.NullString  `json:"analysis_updated"`     // AnalysisUpdated
	TrackInfoUpdated  nulltype.NullString  `json:"track_info_updated"`   // TrackInfoUpdated
	Lyricist          nulltype.NullString  `json:"lyricist"`             // Lyricist
	ISRC              nulltype.NullString  `json:"isrc"`                 // ISRC
	SamplerTrackInfo  nulltype.NullInt64   `json:"sampler_track_info"`   // SamplerTrackInfo
	SamplerPlayOffset nulltype.NullInt64   `json:"sampler_play_offset"`  // SamplerPlayOffset
	SamplerGain       nulltype.NullFloat64 `json:"sampler_gain"`         // SamplerGain
	VideoAssociate    nulltype.NullString  `json:"video_associate"`      // VideoAssociate
	LyricStatus       nulltype.NullInt64   `json:"lyric_status"`         // LyricStatus
	ServiceID         nulltype.NullInt64   `json:"service_id"`           // ServiceID
	OrgFolderPath     nulltype.NullString  `json:"org_folder_path"`      // OrgFolderPath
	Reserved1         nulltype.NullString  `json:"reserved1"`            // Reserved1
	Reserved2         nulltype.NullString  `json:"reserved2"`            // Reserved2
	Reserved3         nulltype.NullString  `json:"reserved3"`            // Reserved3
	Reserved4         nulltype.NullString  `json:"reserved4"`            // Reserved4
	ExtInfo           nulltype.NullString  `json:"ext_info"`             // ExtInfo
	RbFileID          nulltype.NullString  `json:"rb_file_id"`           // rb_file_id
	DeviceID          nulltype.NullString  `json:"device_id"`            // DeviceID
	RbLocalFolderPath nulltype.NullString  `json:"rb_local_folder_path"` // rb_LocalFolderPath
	SrcID             nulltype.NullString  `json:"src_id"`               // SrcID
	SrcTitle          nulltype.NullString  `json:"src_title"`            // SrcTitle
	SrcArtistName     nulltype.NullString  `json:"src_artist_name"`      // SrcArtistName
	SrcAlbumName      nulltype.NullString  `json:"src_album_name"`       // SrcAlbumName
	SrcLength         nulltype.NullInt64   `json:"src_length"`           // SrcLength
	UUID              nulltype.NullString  `json:"uuid"`                 // UUID
	RbDataStatus      nulltype.NullInt64   `json:"rb_data_status"`       // rb_data_status
	RbLocalDataStatus nulltype.NullInt64   `json:"rb_local_data_status"` // rb_local_data_status
	RbLocalDeleted    nulltype.NullInt64   `json:"rb_local_deleted"`     // rb_local_deleted
	RbLocalSynced     nulltype.NullInt64   `json:"rb_local_synced"`      // rb_local_synced
	Usn               nulltype.NullInt64   `json:"usn"`                  // usn
	RbLocalUsn        nulltype.NullInt64   `json:"rb_local_usn"`         // rb_local_usn
	CreatedAt         Time                 `json:"created_at"`           // created_at
	UpdatedAt         Time                 `json:"updated_at"`           // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the DjmdContent exists in the database.
func (dc *DjmdContent) Exists() bool {
	return dc._exists
}

// Deleted returns true when the DjmdContent has been marked for deletion from
// the database.
func (dc *DjmdContent) Deleted() bool {
	return dc._deleted
}

// Insert inserts the DjmdContent to the database.
func (c *Client) InsertDjmdContent(ctx context.Context, dc *DjmdContent) error {
	db := c.db

	switch {
	case dc._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case dc._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO djmdContent (` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $60, $61, $62, $63, $64, $65, $66, $67, $68, $69, $70, $71, $72, $73, $74, $75, $76, $77, $78` +
		`)`
	// run
	logf(sqlstr, dc.ID, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, dc.ID, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	dc._exists = true
	return nil
}

// Update updates a DjmdContent in the database.
func (c *Client) UpdateDjmdContent(ctx context.Context, dc *DjmdContent) error {
	db := c.db

	switch {
	case !dc._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case dc._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE djmdContent SET ` +
		`FolderPath = $1, FileNameL = $2, FileNameS = $3, Title = $4, ArtistID = $5, AlbumID = $6, GenreID = $7, BPM = $8, Length = $9, TrackNo = $10, BitRate = $11, BitDepth = $12, Commnt = $13, FileType = $14, Rating = $15, ReleaseYear = $16, RemixerID = $17, LabelID = $18, OrgArtistID = $19, KeyID = $20, StockDate = $21, ColorID = $22, DJPlayCount = $23, ImagePath = $24, MasterDBID = $25, MasterSongID = $26, AnalysisDataPath = $27, SearchStr = $28, FileSize = $29, DiscNo = $30, ComposerID = $31, Subtitle = $32, SampleRate = $33, DisableQuantize = $34, Analysed = $35, ReleaseDate = $36, DateCreated = $37, ContentLink = $38, Tag = $39, ModifiedByRBM = $40, HotCueAutoLoad = $41, DeliveryControl = $42, DeliveryComment = $43, CueUpdated = $44, AnalysisUpdated = $45, TrackInfoUpdated = $46, Lyricist = $47, ISRC = $48, SamplerTrackInfo = $49, SamplerPlayOffset = $50, SamplerGain = $51, VideoAssociate = $52, LyricStatus = $53, ServiceID = $54, OrgFolderPath = $55, Reserved1 = $56, Reserved2 = $57, Reserved3 = $58, Reserved4 = $59, ExtInfo = $60, rb_file_id = $61, DeviceID = $62, rb_LocalFolderPath = $63, SrcID = $64, SrcTitle = $65, SrcArtistName = $66, SrcAlbumName = $67, SrcLength = $68, UUID = $69, rb_data_status = $70, rb_local_data_status = $71, rb_local_deleted = $72, rb_local_synced = $73, usn = $74, rb_local_usn = $75, created_at = $76, updated_at = $77 ` +
		`WHERE ID = $78`
	// run
	logf(sqlstr, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt, dc.ID)
	if _, err := db.ExecContext(ctx, sqlstr, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt, dc.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the DjmdContent to the database.
func (c *Client) SaveDjmdContent(ctx context.Context, dc *DjmdContent) error {
	if dc.Exists() {
		return c.UpdateDjmdContent(ctx, dc)
	}
	return c.InsertDjmdContent(ctx, dc)
}

// Upsert performs an upsert for DjmdContent.
func (c *Client) UpsertDjmdContent(ctx context.Context, dc *DjmdContent) error {
	db := c.db

	switch {
	case dc._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO djmdContent (` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $60, $61, $62, $63, $64, $65, $66, $67, $68, $69, $70, $71, $72, $73, $74, $75, $76, $77, $78` +
		`)` +
		` ON CONFLICT (ID) DO ` +
		`UPDATE SET ` +
		`FolderPath = EXCLUDED.FolderPath, FileNameL = EXCLUDED.FileNameL, FileNameS = EXCLUDED.FileNameS, Title = EXCLUDED.Title, ArtistID = EXCLUDED.ArtistID, AlbumID = EXCLUDED.AlbumID, GenreID = EXCLUDED.GenreID, BPM = EXCLUDED.BPM, Length = EXCLUDED.Length, TrackNo = EXCLUDED.TrackNo, BitRate = EXCLUDED.BitRate, BitDepth = EXCLUDED.BitDepth, Commnt = EXCLUDED.Commnt, FileType = EXCLUDED.FileType, Rating = EXCLUDED.Rating, ReleaseYear = EXCLUDED.ReleaseYear, RemixerID = EXCLUDED.RemixerID, LabelID = EXCLUDED.LabelID, OrgArtistID = EXCLUDED.OrgArtistID, KeyID = EXCLUDED.KeyID, StockDate = EXCLUDED.StockDate, ColorID = EXCLUDED.ColorID, DJPlayCount = EXCLUDED.DJPlayCount, ImagePath = EXCLUDED.ImagePath, MasterDBID = EXCLUDED.MasterDBID, MasterSongID = EXCLUDED.MasterSongID, AnalysisDataPath = EXCLUDED.AnalysisDataPath, SearchStr = EXCLUDED.SearchStr, FileSize = EXCLUDED.FileSize, DiscNo = EXCLUDED.DiscNo, ComposerID = EXCLUDED.ComposerID, Subtitle = EXCLUDED.Subtitle, SampleRate = EXCLUDED.SampleRate, DisableQuantize = EXCLUDED.DisableQuantize, Analysed = EXCLUDED.Analysed, ReleaseDate = EXCLUDED.ReleaseDate, DateCreated = EXCLUDED.DateCreated, ContentLink = EXCLUDED.ContentLink, Tag = EXCLUDED.Tag, ModifiedByRBM = EXCLUDED.ModifiedByRBM, HotCueAutoLoad = EXCLUDED.HotCueAutoLoad, DeliveryControl = EXCLUDED.DeliveryControl, DeliveryComment = EXCLUDED.DeliveryComment, CueUpdated = EXCLUDED.CueUpdated, AnalysisUpdated = EXCLUDED.AnalysisUpdated, TrackInfoUpdated = EXCLUDED.TrackInfoUpdated, Lyricist = EXCLUDED.Lyricist, ISRC = EXCLUDED.ISRC, SamplerTrackInfo = EXCLUDED.SamplerTrackInfo, SamplerPlayOffset = EXCLUDED.SamplerPlayOffset, SamplerGain = EXCLUDED.SamplerGain, VideoAssociate = EXCLUDED.VideoAssociate, LyricStatus = EXCLUDED.LyricStatus, ServiceID = EXCLUDED.ServiceID, OrgFolderPath = EXCLUDED.OrgFolderPath, Reserved1 = EXCLUDED.Reserved1, Reserved2 = EXCLUDED.Reserved2, Reserved3 = EXCLUDED.Reserved3, Reserved4 = EXCLUDED.Reserved4, ExtInfo = EXCLUDED.ExtInfo, rb_file_id = EXCLUDED.rb_file_id, DeviceID = EXCLUDED.DeviceID, rb_LocalFolderPath = EXCLUDED.rb_LocalFolderPath, SrcID = EXCLUDED.SrcID, SrcTitle = EXCLUDED.SrcTitle, SrcArtistName = EXCLUDED.SrcArtistName, SrcAlbumName = EXCLUDED.SrcAlbumName, SrcLength = EXCLUDED.SrcLength, UUID = EXCLUDED.UUID, rb_data_status = EXCLUDED.rb_data_status, rb_local_data_status = EXCLUDED.rb_local_data_status, rb_local_deleted = EXCLUDED.rb_local_deleted, rb_local_synced = EXCLUDED.rb_local_synced, usn = EXCLUDED.usn, rb_local_usn = EXCLUDED.rb_local_usn, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, dc.ID, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, dc.ID, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	dc._exists = true
	return nil
}

// Delete deletes the DjmdContent from the database.
func (c *Client) DeleteDjmdContent(ctx context.Context, dc *DjmdContent) error {
	db := c.db

	switch {
	case !dc._exists: // doesn't exist
		return nil
	case dc._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM djmdContent ` +
		`WHERE ID = $1`
	// run
	logf(sqlstr, dc.ID)
	if _, err := db.ExecContext(ctx, sqlstr, dc.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	dc._deleted = true
	return nil
}

func scanDjmdContentRows(rows *sql.Rows) ([]*DjmdContent, error) {
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}

	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

func (c *Client) AllDjmdContent(ctx context.Context) ([]*DjmdContent, error) {
	db := c.db

	const sqlstr = `SELECT * FROM DjmdContent`
	rows, err := db.QueryContext(ctx, sqlstr)
	if err != nil {
		return nil, logerror(err)
	}

	defer rows.Close()
	res, err := scanDjmdContentRows(rows)
	if err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByAlbumID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__album_i_d'.
func (c *Client) DjmdContentByAlbumID(ctx context.Context, albumID nulltype.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByAlbumID(ctx context.Context, db DB, albumID nulltype.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE AlbumID = $1`
	// run
	logf(sqlstr, albumID)
	rows, err := db.QueryContext(ctx, sqlstr, albumID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByArtistID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__artist_i_d'.
func (c *Client) DjmdContentByArtistID(ctx context.Context, artistID nulltype.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByArtistID(ctx context.Context, db DB, artistID nulltype.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE ArtistID = $1`
	// run
	logf(sqlstr, artistID)
	rows, err := db.QueryContext(ctx, sqlstr, artistID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByComposerID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__composer_i_d'.
func (c *Client) DjmdContentByComposerID(ctx context.Context, composerID nulltype.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByComposerID(ctx context.Context, db DB, composerID nulltype.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE ComposerID = $1`
	// run
	logf(sqlstr, composerID)
	rows, err := db.QueryContext(ctx, sqlstr, composerID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByGenreID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__genre_i_d'.
func (c *Client) DjmdContentByGenreID(ctx context.Context, genreID nulltype.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByGenreID(ctx context.Context, db DB, genreID nulltype.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE GenreID = $1`
	// run
	logf(sqlstr, genreID)
	rows, err := db.QueryContext(ctx, sqlstr, genreID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByKeyID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__key_i_d'.
func (c *Client) DjmdContentByKeyID(ctx context.Context, keyID nulltype.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByKeyID(ctx context.Context, db DB, keyID nulltype.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE KeyID = $1`
	// run
	logf(sqlstr, keyID)
	rows, err := db.QueryContext(ctx, sqlstr, keyID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByLabelID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__label_i_d'.
func (c *Client) DjmdContentByLabelID(ctx context.Context, labelID nulltype.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByLabelID(ctx context.Context, db DB, labelID nulltype.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE LabelID = $1`
	// run
	logf(sqlstr, labelID)
	rows, err := db.QueryContext(ctx, sqlstr, labelID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByMasterDBIDMasterSongID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__master_d_b_i_d__master_song_i_d'.
func (c *Client) DjmdContentByMasterDBIDMasterSongID(ctx context.Context, masterDBID, masterSongID nulltype.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByMasterDBIDMasterSongID(ctx context.Context, db DB, masterDBID nulltype.NullString, masterSongID nulltype.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE MasterDBID = $1 AND MasterSongID = $2`
	// run
	logf(sqlstr, masterDBID, masterSongID)
	rows, err := db.QueryContext(ctx, sqlstr, masterDBID, masterSongID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByOrgArtistID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__org_artist_i_d'.
func (c *Client) DjmdContentByOrgArtistID(ctx context.Context, orgArtistID nulltype.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByOrgArtistID(ctx context.Context, db DB, orgArtistID nulltype.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE OrgArtistID = $1`
	// run
	logf(sqlstr, orgArtistID)
	rows, err := db.QueryContext(ctx, sqlstr, orgArtistID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRemixerID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__remixer_i_d'.
func (c *Client) DjmdContentByRemixerID(ctx context.Context, remixerID nulltype.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByRemixerID(ctx context.Context, db DB, remixerID nulltype.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE RemixerID = $1`
	// run
	logf(sqlstr, remixerID)
	rows, err := db.QueryContext(ctx, sqlstr, remixerID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByUUID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__u_u_i_d'.
func (c *Client) DjmdContentByUUID(ctx context.Context, uuid nulltype.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByUUID(ctx context.Context, db DB, uuid nulltype.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE UUID = $1`
	// run
	logf(sqlstr, uuid)
	rows, err := db.QueryContext(ctx, sqlstr, uuid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbDataStatus retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_data_status'.
func (c *Client) DjmdContentByRbDataStatus(ctx context.Context, rbDataStatus nulltype.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbDataStatus(ctx context.Context, db DB, rbDataStatus nulltype.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_data_status = $1`
	// run
	logf(sqlstr, rbDataStatus)
	rows, err := db.QueryContext(ctx, sqlstr, rbDataStatus)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDataStatus retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_data_status'.
func (c *Client) DjmdContentByRbLocalDataStatus(ctx context.Context, rbLocalDataStatus nulltype.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDataStatus(ctx context.Context, db DB, rbLocalDataStatus nulltype.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_data_status = $1`
	// run
	logf(sqlstr, rbLocalDataStatus)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDataStatus)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDeleted retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_deleted'.
func (c *Client) DjmdContentByRbLocalDeleted(ctx context.Context, rbLocalDeleted nulltype.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDeleted(ctx context.Context, db DB, rbLocalDeleted nulltype.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_deleted = $1`
	// run
	logf(sqlstr, rbLocalDeleted)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDeletedBitDepth retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_deleted__bit_depth'.
func (c *Client) DjmdContentByRbLocalDeletedBitDepth(ctx context.Context, rbLocalDeleted, bitDepth nulltype.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDeletedBitDepth(ctx context.Context, db DB, rbLocalDeleted nulltype.NullInt64, bitDepth nulltype.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_deleted = $1 AND BitDepth = $2`
	// run
	logf(sqlstr, rbLocalDeleted, bitDepth)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted, bitDepth)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDeletedBitRate retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_deleted__bit_rate'.
func (c *Client) DjmdContentByRbLocalDeletedBitRate(ctx context.Context, rbLocalDeleted, bitRate nulltype.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDeletedBitRate(ctx context.Context, db DB, rbLocalDeleted nulltype.NullInt64, bitRate nulltype.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_deleted = $1 AND BitRate = $2`
	// run
	logf(sqlstr, rbLocalDeleted, bitRate)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted, bitRate)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDeletedFileType retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_deleted__file_type'.
func (c *Client) DjmdContentByRbLocalDeletedFileType(ctx context.Context, rbLocalDeleted, fileType nulltype.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDeletedFileType(ctx context.Context, db DB, rbLocalDeleted nulltype.NullInt64, fileType nulltype.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_deleted = $1 AND FileType = $2`
	// run
	logf(sqlstr, rbLocalDeleted, fileType)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted, fileType)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDeletedServiceID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_deleted__service_i_d'.
func (c *Client) DjmdContentByRbLocalDeletedServiceID(ctx context.Context, rbLocalDeleted, serviceID nulltype.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDeletedServiceID(ctx context.Context, db DB, rbLocalDeleted nulltype.NullInt64, serviceID nulltype.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_deleted = $1 AND ServiceID = $2`
	// run
	logf(sqlstr, rbLocalDeleted, serviceID)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted, serviceID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalUsnID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_usn__i_d'.
func (c *Client) DjmdContentByRbLocalUsnID(ctx context.Context, rbLocalUsn nulltype.NullInt64, id nulltype.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalUsnID(ctx context.Context, db DB, rbLocalUsn nulltype.NullInt64, id nulltype.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_usn = $1 AND ID = $2`
	// run
	logf(sqlstr, rbLocalUsn, id)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalUsn, id)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'sqlite_autoindex_djmdContent_1'.
func (c *Client) DjmdContentByID(ctx context.Context, id nulltype.NullString) (*DjmdContent, error) {
	// func DjmdContentByID(ctx context.Context, db DB, id nulltype.NullString) (*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE ID = $1`
	// run
	logf(sqlstr, id)
	dc := DjmdContent{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &dc, nil
}
