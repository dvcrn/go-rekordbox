package rekordbox

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// DjmdContent represents a row from 'djmdContent'.
type DjmdContent struct {
	ID                sql.NullString  `json:"ID"`                   // ID
	FolderPath        sql.NullString  `json:"FolderPath"`           // FolderPath
	FileNameL         sql.NullString  `json:"FileNameL"`            // FileNameL
	FileNameS         sql.NullString  `json:"FileNameS"`            // FileNameS
	Title             sql.NullString  `json:"Title"`                // Title
	ArtistID          sql.NullString  `json:"ArtistID"`             // ArtistID
	AlbumID           sql.NullString  `json:"AlbumID"`              // AlbumID
	GenreID           sql.NullString  `json:"GenreID"`              // GenreID
	BPM               sql.NullInt64   `json:"BPM"`                  // BPM
	Length            sql.NullInt64   `json:"Length"`               // Length
	TrackNo           sql.NullInt64   `json:"TrackNo"`              // TrackNo
	BitRate           sql.NullInt64   `json:"BitRate"`              // BitRate
	BitDepth          sql.NullInt64   `json:"BitDepth"`             // BitDepth
	Commnt            sql.NullString  `json:"Commnt"`               // Commnt
	FileType          sql.NullInt64   `json:"FileType"`             // FileType
	Rating            sql.NullInt64   `json:"Rating"`               // Rating
	ReleaseYear       sql.NullInt64   `json:"ReleaseYear"`          // ReleaseYear
	RemixerID         sql.NullString  `json:"RemixerID"`            // RemixerID
	LabelID           sql.NullString  `json:"LabelID"`              // LabelID
	OrgArtistID       sql.NullString  `json:"OrgArtistID"`          // OrgArtistID
	KeyID             sql.NullString  `json:"KeyID"`                // KeyID
	StockDate         sql.NullString  `json:"StockDate"`            // StockDate
	ColorID           sql.NullString  `json:"ColorID"`              // ColorID
	DJPlayCount       sql.NullInt64   `json:"DJPlayCount"`          // DJPlayCount
	ImagePath         sql.NullString  `json:"ImagePath"`            // ImagePath
	MasterDBID        sql.NullString  `json:"MasterDBID"`           // MasterDBID
	MasterSongID      sql.NullString  `json:"MasterSongID"`         // MasterSongID
	AnalysisDataPath  sql.NullString  `json:"AnalysisDataPath"`     // AnalysisDataPath
	SearchStr         sql.NullString  `json:"SearchStr"`            // SearchStr
	FileSize          sql.NullInt64   `json:"FileSize"`             // FileSize
	DiscNo            sql.NullInt64   `json:"DiscNo"`               // DiscNo
	ComposerID        sql.NullString  `json:"ComposerID"`           // ComposerID
	Subtitle          sql.NullString  `json:"Subtitle"`             // Subtitle
	SampleRate        sql.NullInt64   `json:"SampleRate"`           // SampleRate
	DisableQuantize   sql.NullInt64   `json:"DisableQuantize"`      // DisableQuantize
	Analysed          sql.NullInt64   `json:"Analysed"`             // Analysed
	ReleaseDate       sql.NullString  `json:"ReleaseDate"`          // ReleaseDate
	DateCreated       sql.NullString  `json:"DateCreated"`          // DateCreated
	ContentLink       sql.NullInt64   `json:"ContentLink"`          // ContentLink
	Tag               sql.NullString  `json:"Tag"`                  // Tag
	ModifiedByRBM     sql.NullString  `json:"ModifiedByRBM"`        // ModifiedByRBM
	HotCueAutoLoad    sql.NullString  `json:"HotCueAutoLoad"`       // HotCueAutoLoad
	DeliveryControl   sql.NullString  `json:"DeliveryControl"`      // DeliveryControl
	DeliveryComment   sql.NullString  `json:"DeliveryComment"`      // DeliveryComment
	CueUpdated        sql.NullString  `json:"CueUpdated"`           // CueUpdated
	AnalysisUpdated   sql.NullString  `json:"AnalysisUpdated"`      // AnalysisUpdated
	TrackInfoUpdated  sql.NullString  `json:"TrackInfoUpdated"`     // TrackInfoUpdated
	Lyricist          sql.NullString  `json:"Lyricist"`             // Lyricist
	ISRC              sql.NullString  `json:"ISRC"`                 // ISRC
	SamplerTrackInfo  sql.NullInt64   `json:"SamplerTrackInfo"`     // SamplerTrackInfo
	SamplerPlayOffset sql.NullInt64   `json:"SamplerPlayOffset"`    // SamplerPlayOffset
	SamplerGain       sql.NullFloat64 `json:"SamplerGain"`          // SamplerGain
	VideoAssociate    sql.NullString  `json:"VideoAssociate"`       // VideoAssociate
	LyricStatus       sql.NullInt64   `json:"LyricStatus"`          // LyricStatus
	ServiceID         sql.NullInt64   `json:"ServiceID"`            // ServiceID
	OrgFolderPath     sql.NullString  `json:"OrgFolderPath"`        // OrgFolderPath
	Reserved1         sql.NullString  `json:"Reserved1"`            // Reserved1
	Reserved2         sql.NullString  `json:"Reserved2"`            // Reserved2
	Reserved3         sql.NullString  `json:"Reserved3"`            // Reserved3
	Reserved4         sql.NullString  `json:"Reserved4"`            // Reserved4
	ExtInfo           sql.NullString  `json:"ExtInfo"`              // ExtInfo
	RbFileID          sql.NullString  `json:"rb_file_id"`           // rb_file_id
	DeviceID          sql.NullString  `json:"DeviceID"`             // DeviceID
	RbLocalFolderPath sql.NullString  `json:"rb_LocalFolderPath"`   // rb_LocalFolderPath
	SrcID             sql.NullString  `json:"SrcID"`                // SrcID
	SrcTitle          sql.NullString  `json:"SrcTitle"`             // SrcTitle
	SrcArtistName     sql.NullString  `json:"SrcArtistName"`        // SrcArtistName
	SrcAlbumName      sql.NullString  `json:"SrcAlbumName"`         // SrcAlbumName
	SrcLength         sql.NullInt64   `json:"SrcLength"`            // SrcLength
	UUID              sql.NullString  `json:"UUID"`                 // UUID
	RbDataStatus      sql.NullInt64   `json:"rb_data_status"`       // rb_data_status
	RbLocalDataStatus sql.NullInt64   `json:"rb_local_data_status"` // rb_local_data_status
	RbLocalDeleted    sql.NullInt64   `json:"rb_local_deleted"`     // rb_local_deleted
	RbLocalSynced     sql.NullInt64   `json:"rb_local_synced"`      // rb_local_synced
	Usn               sql.NullInt64   `json:"usn"`                  // usn
	RbLocalUsn        sql.NullInt64   `json:"rb_local_usn"`         // rb_local_usn
	CreatedAt         Time            `json:"created_at"`           // created_at
	UpdatedAt         Time            `json:"updated_at"`           // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the DjmdContent exists in the database.
func (dc *DjmdContent) Exists() bool {
	return dc._exists
}

// Deleted returns true when the DjmdContent has been marked for deletion from
// the database.
func (dc *DjmdContent) Deleted() bool {
	return dc._deleted
}

// Insert inserts the DjmdContent to the database.
func (c *Client) InsertDjmdContent(ctx context.Context, dc *DjmdContent) error {
	db := c.db

	switch {
	case dc._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case dc._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO djmdContent (` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $60, $61, $62, $63, $64, $65, $66, $67, $68, $69, $70, $71, $72, $73, $74, $75, $76, $77, $78` +
		`)`
	// run
	logf(sqlstr, dc.ID, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, dc.ID, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	dc._exists = true
	return nil
}

// Update updates a DjmdContent in the database.
func (c *Client) UpdateDjmdContent(ctx context.Context, dc *DjmdContent) error {
	db := c.db

	switch {
	case !dc._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case dc._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE djmdContent SET ` +
		`FolderPath = $1, FileNameL = $2, FileNameS = $3, Title = $4, ArtistID = $5, AlbumID = $6, GenreID = $7, BPM = $8, Length = $9, TrackNo = $10, BitRate = $11, BitDepth = $12, Commnt = $13, FileType = $14, Rating = $15, ReleaseYear = $16, RemixerID = $17, LabelID = $18, OrgArtistID = $19, KeyID = $20, StockDate = $21, ColorID = $22, DJPlayCount = $23, ImagePath = $24, MasterDBID = $25, MasterSongID = $26, AnalysisDataPath = $27, SearchStr = $28, FileSize = $29, DiscNo = $30, ComposerID = $31, Subtitle = $32, SampleRate = $33, DisableQuantize = $34, Analysed = $35, ReleaseDate = $36, DateCreated = $37, ContentLink = $38, Tag = $39, ModifiedByRBM = $40, HotCueAutoLoad = $41, DeliveryControl = $42, DeliveryComment = $43, CueUpdated = $44, AnalysisUpdated = $45, TrackInfoUpdated = $46, Lyricist = $47, ISRC = $48, SamplerTrackInfo = $49, SamplerPlayOffset = $50, SamplerGain = $51, VideoAssociate = $52, LyricStatus = $53, ServiceID = $54, OrgFolderPath = $55, Reserved1 = $56, Reserved2 = $57, Reserved3 = $58, Reserved4 = $59, ExtInfo = $60, rb_file_id = $61, DeviceID = $62, rb_LocalFolderPath = $63, SrcID = $64, SrcTitle = $65, SrcArtistName = $66, SrcAlbumName = $67, SrcLength = $68, UUID = $69, rb_data_status = $70, rb_local_data_status = $71, rb_local_deleted = $72, rb_local_synced = $73, usn = $74, rb_local_usn = $75, created_at = $76, updated_at = $77 ` +
		`WHERE ID = $78`
	// run
	logf(sqlstr, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt, dc.ID)
	if _, err := db.ExecContext(ctx, sqlstr, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt, dc.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the DjmdContent to the database.
func (c *Client) SaveDjmdContent(ctx context.Context, dc *DjmdContent) error {
	if dc.Exists() {
		return c.UpdateDjmdContent(ctx, dc)
	}
	return c.InsertDjmdContent(ctx, dc)
}

// Upsert performs an upsert for DjmdContent.
func (c *Client) UpsertDjmdContent(ctx context.Context, dc *DjmdContent) error {
	db := c.db

	switch {
	case dc._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO djmdContent (` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $60, $61, $62, $63, $64, $65, $66, $67, $68, $69, $70, $71, $72, $73, $74, $75, $76, $77, $78` +
		`)` +
		` ON CONFLICT (ID) DO ` +
		`UPDATE SET ` +
		`FolderPath = EXCLUDED.FolderPath, FileNameL = EXCLUDED.FileNameL, FileNameS = EXCLUDED.FileNameS, Title = EXCLUDED.Title, ArtistID = EXCLUDED.ArtistID, AlbumID = EXCLUDED.AlbumID, GenreID = EXCLUDED.GenreID, BPM = EXCLUDED.BPM, Length = EXCLUDED.Length, TrackNo = EXCLUDED.TrackNo, BitRate = EXCLUDED.BitRate, BitDepth = EXCLUDED.BitDepth, Commnt = EXCLUDED.Commnt, FileType = EXCLUDED.FileType, Rating = EXCLUDED.Rating, ReleaseYear = EXCLUDED.ReleaseYear, RemixerID = EXCLUDED.RemixerID, LabelID = EXCLUDED.LabelID, OrgArtistID = EXCLUDED.OrgArtistID, KeyID = EXCLUDED.KeyID, StockDate = EXCLUDED.StockDate, ColorID = EXCLUDED.ColorID, DJPlayCount = EXCLUDED.DJPlayCount, ImagePath = EXCLUDED.ImagePath, MasterDBID = EXCLUDED.MasterDBID, MasterSongID = EXCLUDED.MasterSongID, AnalysisDataPath = EXCLUDED.AnalysisDataPath, SearchStr = EXCLUDED.SearchStr, FileSize = EXCLUDED.FileSize, DiscNo = EXCLUDED.DiscNo, ComposerID = EXCLUDED.ComposerID, Subtitle = EXCLUDED.Subtitle, SampleRate = EXCLUDED.SampleRate, DisableQuantize = EXCLUDED.DisableQuantize, Analysed = EXCLUDED.Analysed, ReleaseDate = EXCLUDED.ReleaseDate, DateCreated = EXCLUDED.DateCreated, ContentLink = EXCLUDED.ContentLink, Tag = EXCLUDED.Tag, ModifiedByRBM = EXCLUDED.ModifiedByRBM, HotCueAutoLoad = EXCLUDED.HotCueAutoLoad, DeliveryControl = EXCLUDED.DeliveryControl, DeliveryComment = EXCLUDED.DeliveryComment, CueUpdated = EXCLUDED.CueUpdated, AnalysisUpdated = EXCLUDED.AnalysisUpdated, TrackInfoUpdated = EXCLUDED.TrackInfoUpdated, Lyricist = EXCLUDED.Lyricist, ISRC = EXCLUDED.ISRC, SamplerTrackInfo = EXCLUDED.SamplerTrackInfo, SamplerPlayOffset = EXCLUDED.SamplerPlayOffset, SamplerGain = EXCLUDED.SamplerGain, VideoAssociate = EXCLUDED.VideoAssociate, LyricStatus = EXCLUDED.LyricStatus, ServiceID = EXCLUDED.ServiceID, OrgFolderPath = EXCLUDED.OrgFolderPath, Reserved1 = EXCLUDED.Reserved1, Reserved2 = EXCLUDED.Reserved2, Reserved3 = EXCLUDED.Reserved3, Reserved4 = EXCLUDED.Reserved4, ExtInfo = EXCLUDED.ExtInfo, rb_file_id = EXCLUDED.rb_file_id, DeviceID = EXCLUDED.DeviceID, rb_LocalFolderPath = EXCLUDED.rb_LocalFolderPath, SrcID = EXCLUDED.SrcID, SrcTitle = EXCLUDED.SrcTitle, SrcArtistName = EXCLUDED.SrcArtistName, SrcAlbumName = EXCLUDED.SrcAlbumName, SrcLength = EXCLUDED.SrcLength, UUID = EXCLUDED.UUID, rb_data_status = EXCLUDED.rb_data_status, rb_local_data_status = EXCLUDED.rb_local_data_status, rb_local_deleted = EXCLUDED.rb_local_deleted, rb_local_synced = EXCLUDED.rb_local_synced, usn = EXCLUDED.usn, rb_local_usn = EXCLUDED.rb_local_usn, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, dc.ID, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, dc.ID, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	dc._exists = true
	return nil
}

// Delete deletes the DjmdContent from the database.
func (c *Client) DeleteDjmdContent(ctx context.Context, dc *DjmdContent) error {
	db := c.db

	switch {
	case !dc._exists: // doesn't exist
		return nil
	case dc._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM djmdContent ` +
		`WHERE ID = $1`
	// run
	logf(sqlstr, dc.ID)
	if _, err := db.ExecContext(ctx, sqlstr, dc.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	dc._deleted = true
	return nil
}

func (c *Client) AllDjmdContent(ctx context.Context) ([]*DjmdContent, error) {
	db := c.db

	const sqlstr = `SELECT * FROM DjmdContent`
	rows, err := db.QueryContext(ctx, sqlstr)
	if err != nil {
		return nil, logerror(err)
	}

	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByAlbumID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__album_i_d'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByAlbumID(ctx context.Context, db DB, albumID sql.NullString) ([]*DjmdContent, error) {
// DjmdContentByAlbumID {
// func DjmdContentByAlbumID(db DB, albumID sql.NullString) ([]*DjmdContent, error) {
// true
// albumID
// DjmdContent
// DjmdContentByAlbumID
// false
// false
func (c *Client) DjmdContentByAlbumID(ctx context.Context, albumID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByAlbumID(ctx context.Context, db DB, albumID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE AlbumID = $1`
	// run
	logf(sqlstr, albumID)
	rows, err := db.QueryContext(ctx, sqlstr, albumID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByArtistID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__artist_i_d'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByArtistID(ctx context.Context, db DB, artistID sql.NullString) ([]*DjmdContent, error) {
// DjmdContentByArtistID {
// func DjmdContentByArtistID(db DB, artistID sql.NullString) ([]*DjmdContent, error) {
// true
// artistID
// DjmdContent
// DjmdContentByArtistID
// false
// false
func (c *Client) DjmdContentByArtistID(ctx context.Context, artistID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByArtistID(ctx context.Context, db DB, artistID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE ArtistID = $1`
	// run
	logf(sqlstr, artistID)
	rows, err := db.QueryContext(ctx, sqlstr, artistID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByComposerID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__composer_i_d'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByComposerID(ctx context.Context, db DB, composerID sql.NullString) ([]*DjmdContent, error) {
// DjmdContentByComposerID {
// func DjmdContentByComposerID(db DB, composerID sql.NullString) ([]*DjmdContent, error) {
// true
// composerID
// DjmdContent
// DjmdContentByComposerID
// false
// false
func (c *Client) DjmdContentByComposerID(ctx context.Context, composerID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByComposerID(ctx context.Context, db DB, composerID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE ComposerID = $1`
	// run
	logf(sqlstr, composerID)
	rows, err := db.QueryContext(ctx, sqlstr, composerID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByGenreID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__genre_i_d'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByGenreID(ctx context.Context, db DB, genreID sql.NullString) ([]*DjmdContent, error) {
// DjmdContentByGenreID {
// func DjmdContentByGenreID(db DB, genreID sql.NullString) ([]*DjmdContent, error) {
// true
// genreID
// DjmdContent
// DjmdContentByGenreID
// false
// false
func (c *Client) DjmdContentByGenreID(ctx context.Context, genreID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByGenreID(ctx context.Context, db DB, genreID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE GenreID = $1`
	// run
	logf(sqlstr, genreID)
	rows, err := db.QueryContext(ctx, sqlstr, genreID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByKeyID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__key_i_d'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByKeyID(ctx context.Context, db DB, keyID sql.NullString) ([]*DjmdContent, error) {
// DjmdContentByKeyID {
// func DjmdContentByKeyID(db DB, keyID sql.NullString) ([]*DjmdContent, error) {
// true
// keyID
// DjmdContent
// DjmdContentByKeyID
// false
// false
func (c *Client) DjmdContentByKeyID(ctx context.Context, keyID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByKeyID(ctx context.Context, db DB, keyID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE KeyID = $1`
	// run
	logf(sqlstr, keyID)
	rows, err := db.QueryContext(ctx, sqlstr, keyID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByLabelID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__label_i_d'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByLabelID(ctx context.Context, db DB, labelID sql.NullString) ([]*DjmdContent, error) {
// DjmdContentByLabelID {
// func DjmdContentByLabelID(db DB, labelID sql.NullString) ([]*DjmdContent, error) {
// true
// labelID
// DjmdContent
// DjmdContentByLabelID
// false
// false
func (c *Client) DjmdContentByLabelID(ctx context.Context, labelID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByLabelID(ctx context.Context, db DB, labelID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE LabelID = $1`
	// run
	logf(sqlstr, labelID)
	rows, err := db.QueryContext(ctx, sqlstr, labelID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByMasterDBIDMasterSongID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__master_d_b_i_d__master_song_i_d'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByMasterDBIDMasterSongID(ctx context.Context, db DB, masterDBID sql.NullString, masterSongID sql.NullString) ([]*DjmdContent, error) {
// DjmdContentByMasterDBIDMasterSongID {
// func DjmdContentByMasterDBIDMasterSongID(db DB, masterDBID sql.NullString, masterSongID sql.NullString) ([]*DjmdContent, error) {
// true
// masterDBID, masterSongID
// DjmdContent
// DjmdContentByMasterDBIDMasterSongID
// false
// false
func (c *Client) DjmdContentByMasterDBIDMasterSongID(ctx context.Context, masterDBID, masterSongID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByMasterDBIDMasterSongID(ctx context.Context, db DB, masterDBID sql.NullString, masterSongID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE MasterDBID = $1 AND MasterSongID = $2`
	// run
	logf(sqlstr, masterDBID, masterSongID)
	rows, err := db.QueryContext(ctx, sqlstr, masterDBID, masterSongID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByOrgArtistID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__org_artist_i_d'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByOrgArtistID(ctx context.Context, db DB, orgArtistID sql.NullString) ([]*DjmdContent, error) {
// DjmdContentByOrgArtistID {
// func DjmdContentByOrgArtistID(db DB, orgArtistID sql.NullString) ([]*DjmdContent, error) {
// true
// orgArtistID
// DjmdContent
// DjmdContentByOrgArtistID
// false
// false
func (c *Client) DjmdContentByOrgArtistID(ctx context.Context, orgArtistID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByOrgArtistID(ctx context.Context, db DB, orgArtistID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE OrgArtistID = $1`
	// run
	logf(sqlstr, orgArtistID)
	rows, err := db.QueryContext(ctx, sqlstr, orgArtistID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRemixerID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__remixer_i_d'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByRemixerID(ctx context.Context, db DB, remixerID sql.NullString) ([]*DjmdContent, error) {
// DjmdContentByRemixerID {
// func DjmdContentByRemixerID(db DB, remixerID sql.NullString) ([]*DjmdContent, error) {
// true
// remixerID
// DjmdContent
// DjmdContentByRemixerID
// false
// false
func (c *Client) DjmdContentByRemixerID(ctx context.Context, remixerID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByRemixerID(ctx context.Context, db DB, remixerID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE RemixerID = $1`
	// run
	logf(sqlstr, remixerID)
	rows, err := db.QueryContext(ctx, sqlstr, remixerID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByUUID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__u_u_i_d'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByUUID(ctx context.Context, db DB, uuid sql.NullString) ([]*DjmdContent, error) {
// DjmdContentByUUID {
// func DjmdContentByUUID(db DB, uuid sql.NullString) ([]*DjmdContent, error) {
// true
// uuid
// DjmdContent
// DjmdContentByUUID
// false
// false
func (c *Client) DjmdContentByUUID(ctx context.Context, uuid sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByUUID(ctx context.Context, db DB, uuid sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE UUID = $1`
	// run
	logf(sqlstr, uuid)
	rows, err := db.QueryContext(ctx, sqlstr, uuid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbDataStatus retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_data_status'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByRbDataStatus(ctx context.Context, db DB, rbDataStatus sql.NullInt64) ([]*DjmdContent, error) {
// DjmdContentByRbDataStatus {
// func DjmdContentByRbDataStatus(db DB, rbDataStatus sql.NullInt64) ([]*DjmdContent, error) {
// true
// rbDataStatus
// DjmdContent
// DjmdContentByRbDataStatus
// false
// false
func (c *Client) DjmdContentByRbDataStatus(ctx context.Context, rbDataStatus sql.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbDataStatus(ctx context.Context, db DB, rbDataStatus sql.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_data_status = $1`
	// run
	logf(sqlstr, rbDataStatus)
	rows, err := db.QueryContext(ctx, sqlstr, rbDataStatus)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDataStatus retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_data_status'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByRbLocalDataStatus(ctx context.Context, db DB, rbLocalDataStatus sql.NullInt64) ([]*DjmdContent, error) {
// DjmdContentByRbLocalDataStatus {
// func DjmdContentByRbLocalDataStatus(db DB, rbLocalDataStatus sql.NullInt64) ([]*DjmdContent, error) {
// true
// rbLocalDataStatus
// DjmdContent
// DjmdContentByRbLocalDataStatus
// false
// false
func (c *Client) DjmdContentByRbLocalDataStatus(ctx context.Context, rbLocalDataStatus sql.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDataStatus(ctx context.Context, db DB, rbLocalDataStatus sql.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_data_status = $1`
	// run
	logf(sqlstr, rbLocalDataStatus)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDataStatus)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDeleted retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_deleted'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByRbLocalDeleted(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64) ([]*DjmdContent, error) {
// DjmdContentByRbLocalDeleted {
// func DjmdContentByRbLocalDeleted(db DB, rbLocalDeleted sql.NullInt64) ([]*DjmdContent, error) {
// true
// rbLocalDeleted
// DjmdContent
// DjmdContentByRbLocalDeleted
// false
// false
func (c *Client) DjmdContentByRbLocalDeleted(ctx context.Context, rbLocalDeleted sql.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDeleted(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_deleted = $1`
	// run
	logf(sqlstr, rbLocalDeleted)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDeletedBitDepth retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_deleted__bit_depth'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByRbLocalDeletedBitDepth(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64, bitDepth sql.NullInt64) ([]*DjmdContent, error) {
// DjmdContentByRbLocalDeletedBitDepth {
// func DjmdContentByRbLocalDeletedBitDepth(db DB, rbLocalDeleted sql.NullInt64, bitDepth sql.NullInt64) ([]*DjmdContent, error) {
// true
// rbLocalDeleted, bitDepth
// DjmdContent
// DjmdContentByRbLocalDeletedBitDepth
// false
// false
func (c *Client) DjmdContentByRbLocalDeletedBitDepth(ctx context.Context, rbLocalDeleted, bitDepth sql.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDeletedBitDepth(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64, bitDepth sql.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_deleted = $1 AND BitDepth = $2`
	// run
	logf(sqlstr, rbLocalDeleted, bitDepth)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted, bitDepth)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDeletedBitRate retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_deleted__bit_rate'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByRbLocalDeletedBitRate(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64, bitRate sql.NullInt64) ([]*DjmdContent, error) {
// DjmdContentByRbLocalDeletedBitRate {
// func DjmdContentByRbLocalDeletedBitRate(db DB, rbLocalDeleted sql.NullInt64, bitRate sql.NullInt64) ([]*DjmdContent, error) {
// true
// rbLocalDeleted, bitRate
// DjmdContent
// DjmdContentByRbLocalDeletedBitRate
// false
// false
func (c *Client) DjmdContentByRbLocalDeletedBitRate(ctx context.Context, rbLocalDeleted, bitRate sql.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDeletedBitRate(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64, bitRate sql.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_deleted = $1 AND BitRate = $2`
	// run
	logf(sqlstr, rbLocalDeleted, bitRate)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted, bitRate)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDeletedFileType retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_deleted__file_type'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByRbLocalDeletedFileType(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64, fileType sql.NullInt64) ([]*DjmdContent, error) {
// DjmdContentByRbLocalDeletedFileType {
// func DjmdContentByRbLocalDeletedFileType(db DB, rbLocalDeleted sql.NullInt64, fileType sql.NullInt64) ([]*DjmdContent, error) {
// true
// rbLocalDeleted, fileType
// DjmdContent
// DjmdContentByRbLocalDeletedFileType
// false
// false
func (c *Client) DjmdContentByRbLocalDeletedFileType(ctx context.Context, rbLocalDeleted, fileType sql.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDeletedFileType(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64, fileType sql.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_deleted = $1 AND FileType = $2`
	// run
	logf(sqlstr, rbLocalDeleted, fileType)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted, fileType)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDeletedServiceID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_deleted__service_i_d'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByRbLocalDeletedServiceID(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64, serviceID sql.NullInt64) ([]*DjmdContent, error) {
// DjmdContentByRbLocalDeletedServiceID {
// func DjmdContentByRbLocalDeletedServiceID(db DB, rbLocalDeleted sql.NullInt64, serviceID sql.NullInt64) ([]*DjmdContent, error) {
// true
// rbLocalDeleted, serviceID
// DjmdContent
// DjmdContentByRbLocalDeletedServiceID
// false
// false
func (c *Client) DjmdContentByRbLocalDeletedServiceID(ctx context.Context, rbLocalDeleted, serviceID sql.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDeletedServiceID(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64, serviceID sql.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_deleted = $1 AND ServiceID = $2`
	// run
	logf(sqlstr, rbLocalDeleted, serviceID)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted, serviceID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalUsnID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_usn__i_d'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByRbLocalUsnID(ctx context.Context, db DB, rbLocalUsn sql.NullInt64, id sql.NullString) ([]*DjmdContent, error) {
// DjmdContentByRbLocalUsnID {
// func DjmdContentByRbLocalUsnID(db DB, rbLocalUsn sql.NullInt64, id sql.NullString) ([]*DjmdContent, error) {
// true
// rbLocalUsn, id
// DjmdContent
// DjmdContentByRbLocalUsnID
// false
// false
func (c *Client) DjmdContentByRbLocalUsnID(ctx context.Context, rbLocalUsn sql.NullInt64, id sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalUsnID(ctx context.Context, db DB, rbLocalUsn sql.NullInt64, id sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_usn = $1 AND ID = $2`
	// run
	logf(sqlstr, rbLocalUsn, id)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalUsn, id)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'sqlite_autoindex_djmdContent_1'.
// func (dc *DjmdContent) djmdContent(db DB) (error)
// func DjmdContentByID(ctx context.Context, db DB, id sql.NullString) (*DjmdContent, error) {
// DjmdContentByID {
// func DjmdContentByID(db DB, id sql.NullString) (*DjmdContent, error) {
// true
// id
// DjmdContent
// DjmdContentByID
// true
// true
func (c *Client) DjmdContentByID(ctx context.Context, id sql.NullString) (*DjmdContent, error) {
	// func DjmdContentByID(ctx context.Context, db DB, id sql.NullString) (*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE ID = $1`
	// run
	logf(sqlstr, id)
	dc := DjmdContent{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &dc, nil
}
