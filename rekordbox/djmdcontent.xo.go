package rekordbox

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// DjmdContent represents a row from 'djmdContent'.
type DjmdContent struct {
	ID                sql.NullString  `json:"id"`                   // ID
	FolderPath        sql.NullString  `json:"folder_path"`          // FolderPath
	FileNameL         sql.NullString  `json:"file_name_l"`          // FileNameL
	FileNameS         sql.NullString  `json:"file_name_s"`          // FileNameS
	Title             sql.NullString  `json:"title"`                // Title
	ArtistID          sql.NullString  `json:"artist_id"`            // ArtistID
	AlbumID           sql.NullString  `json:"album_id"`             // AlbumID
	GenreID           sql.NullString  `json:"genre_id"`             // GenreID
	BPM               sql.NullInt64   `json:"bpm"`                  // BPM
	Length            sql.NullInt64   `json:"length"`               // Length
	TrackNo           sql.NullInt64   `json:"track_no"`             // TrackNo
	BitRate           sql.NullInt64   `json:"bit_rate"`             // BitRate
	BitDepth          sql.NullInt64   `json:"bit_depth"`            // BitDepth
	Commnt            sql.NullString  `json:"commnt"`               // Commnt
	FileType          sql.NullInt64   `json:"file_type"`            // FileType
	Rating            sql.NullInt64   `json:"rating"`               // Rating
	ReleaseYear       sql.NullInt64   `json:"release_year"`         // ReleaseYear
	RemixerID         sql.NullString  `json:"remixer_id"`           // RemixerID
	LabelID           sql.NullString  `json:"label_id"`             // LabelID
	OrgArtistID       sql.NullString  `json:"org_artist_id"`        // OrgArtistID
	KeyID             sql.NullString  `json:"key_id"`               // KeyID
	StockDate         sql.NullString  `json:"stock_date"`           // StockDate
	ColorID           sql.NullString  `json:"color_id"`             // ColorID
	DJPlayCount       sql.NullInt64   `json:"dj_play_count"`        // DJPlayCount
	ImagePath         sql.NullString  `json:"image_path"`           // ImagePath
	MasterDBID        sql.NullString  `json:"master_dbid"`          // MasterDBID
	MasterSongID      sql.NullString  `json:"master_song_id"`       // MasterSongID
	AnalysisDataPath  sql.NullString  `json:"analysis_data_path"`   // AnalysisDataPath
	SearchStr         sql.NullString  `json:"search_str"`           // SearchStr
	FileSize          sql.NullInt64   `json:"file_size"`            // FileSize
	DiscNo            sql.NullInt64   `json:"disc_no"`              // DiscNo
	ComposerID        sql.NullString  `json:"composer_id"`          // ComposerID
	Subtitle          sql.NullString  `json:"subtitle"`             // Subtitle
	SampleRate        sql.NullInt64   `json:"sample_rate"`          // SampleRate
	DisableQuantize   sql.NullInt64   `json:"disable_quantize"`     // DisableQuantize
	Analysed          sql.NullInt64   `json:"analysed"`             // Analysed
	ReleaseDate       sql.NullString  `json:"release_date"`         // ReleaseDate
	DateCreated       sql.NullString  `json:"date_created"`         // DateCreated
	ContentLink       sql.NullInt64   `json:"content_link"`         // ContentLink
	Tag               sql.NullString  `json:"tag"`                  // Tag
	ModifiedByRBM     sql.NullString  `json:"modified_by_rbm"`      // ModifiedByRBM
	HotCueAutoLoad    sql.NullString  `json:"hot_cue_auto_load"`    // HotCueAutoLoad
	DeliveryControl   sql.NullString  `json:"delivery_control"`     // DeliveryControl
	DeliveryComment   sql.NullString  `json:"delivery_comment"`     // DeliveryComment
	CueUpdated        sql.NullString  `json:"cue_updated"`          // CueUpdated
	AnalysisUpdated   sql.NullString  `json:"analysis_updated"`     // AnalysisUpdated
	TrackInfoUpdated  sql.NullString  `json:"track_info_updated"`   // TrackInfoUpdated
	Lyricist          sql.NullString  `json:"lyricist"`             // Lyricist
	ISRC              sql.NullString  `json:"isrc"`                 // ISRC
	SamplerTrackInfo  sql.NullInt64   `json:"sampler_track_info"`   // SamplerTrackInfo
	SamplerPlayOffset sql.NullInt64   `json:"sampler_play_offset"`  // SamplerPlayOffset
	SamplerGain       sql.NullFloat64 `json:"sampler_gain"`         // SamplerGain
	VideoAssociate    sql.NullString  `json:"video_associate"`      // VideoAssociate
	LyricStatus       sql.NullInt64   `json:"lyric_status"`         // LyricStatus
	ServiceID         sql.NullInt64   `json:"service_id"`           // ServiceID
	OrgFolderPath     sql.NullString  `json:"org_folder_path"`      // OrgFolderPath
	Reserved1         sql.NullString  `json:"reserved1"`            // Reserved1
	Reserved2         sql.NullString  `json:"reserved2"`            // Reserved2
	Reserved3         sql.NullString  `json:"reserved3"`            // Reserved3
	Reserved4         sql.NullString  `json:"reserved4"`            // Reserved4
	ExtInfo           sql.NullString  `json:"ext_info"`             // ExtInfo
	RbFileID          sql.NullString  `json:"rb_file_id"`           // rb_file_id
	DeviceID          sql.NullString  `json:"device_id"`            // DeviceID
	RbLocalFolderPath sql.NullString  `json:"rb_local_folder_path"` // rb_LocalFolderPath
	SrcID             sql.NullString  `json:"src_id"`               // SrcID
	SrcTitle          sql.NullString  `json:"src_title"`            // SrcTitle
	SrcArtistName     sql.NullString  `json:"src_artist_name"`      // SrcArtistName
	SrcAlbumName      sql.NullString  `json:"src_album_name"`       // SrcAlbumName
	SrcLength         sql.NullInt64   `json:"src_length"`           // SrcLength
	UUID              sql.NullString  `json:"uuid"`                 // UUID
	RbDataStatus      sql.NullInt64   `json:"rb_data_status"`       // rb_data_status
	RbLocalDataStatus sql.NullInt64   `json:"rb_local_data_status"` // rb_local_data_status
	RbLocalDeleted    sql.NullInt64   `json:"rb_local_deleted"`     // rb_local_deleted
	RbLocalSynced     sql.NullInt64   `json:"rb_local_synced"`      // rb_local_synced
	Usn               sql.NullInt64   `json:"usn"`                  // usn
	RbLocalUsn        sql.NullInt64   `json:"rb_local_usn"`         // rb_local_usn
	CreatedAt         Time            `json:"created_at"`           // created_at
	UpdatedAt         Time            `json:"updated_at"`           // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the DjmdContent exists in the database.
func (dc *DjmdContent) Exists() bool {
	return dc._exists
}

// Deleted returns true when the DjmdContent has been marked for deletion from
// the database.
func (dc *DjmdContent) Deleted() bool {
	return dc._deleted
}

// Insert inserts the DjmdContent to the database.
func (c *Client) InsertDjmdContent(ctx context.Context, dc *DjmdContent) error {
	db := c.db

	switch {
	case dc._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case dc._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO djmdContent (` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $60, $61, $62, $63, $64, $65, $66, $67, $68, $69, $70, $71, $72, $73, $74, $75, $76, $77, $78` +
		`)`
	// run
	logf(sqlstr, dc.ID, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, dc.ID, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	dc._exists = true
	return nil
}

// Update updates a DjmdContent in the database.
func (c *Client) UpdateDjmdContent(ctx context.Context, dc *DjmdContent) error {
	db := c.db

	switch {
	case !dc._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case dc._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE djmdContent SET ` +
		`FolderPath = $1, FileNameL = $2, FileNameS = $3, Title = $4, ArtistID = $5, AlbumID = $6, GenreID = $7, BPM = $8, Length = $9, TrackNo = $10, BitRate = $11, BitDepth = $12, Commnt = $13, FileType = $14, Rating = $15, ReleaseYear = $16, RemixerID = $17, LabelID = $18, OrgArtistID = $19, KeyID = $20, StockDate = $21, ColorID = $22, DJPlayCount = $23, ImagePath = $24, MasterDBID = $25, MasterSongID = $26, AnalysisDataPath = $27, SearchStr = $28, FileSize = $29, DiscNo = $30, ComposerID = $31, Subtitle = $32, SampleRate = $33, DisableQuantize = $34, Analysed = $35, ReleaseDate = $36, DateCreated = $37, ContentLink = $38, Tag = $39, ModifiedByRBM = $40, HotCueAutoLoad = $41, DeliveryControl = $42, DeliveryComment = $43, CueUpdated = $44, AnalysisUpdated = $45, TrackInfoUpdated = $46, Lyricist = $47, ISRC = $48, SamplerTrackInfo = $49, SamplerPlayOffset = $50, SamplerGain = $51, VideoAssociate = $52, LyricStatus = $53, ServiceID = $54, OrgFolderPath = $55, Reserved1 = $56, Reserved2 = $57, Reserved3 = $58, Reserved4 = $59, ExtInfo = $60, rb_file_id = $61, DeviceID = $62, rb_LocalFolderPath = $63, SrcID = $64, SrcTitle = $65, SrcArtistName = $66, SrcAlbumName = $67, SrcLength = $68, UUID = $69, rb_data_status = $70, rb_local_data_status = $71, rb_local_deleted = $72, rb_local_synced = $73, usn = $74, rb_local_usn = $75, created_at = $76, updated_at = $77 ` +
		`WHERE ID = $78`
	// run
	logf(sqlstr, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt, dc.ID)
	if _, err := db.ExecContext(ctx, sqlstr, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt, dc.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the DjmdContent to the database.
func (c *Client) SaveDjmdContent(ctx context.Context, dc *DjmdContent) error {
	if dc.Exists() {
		return c.UpdateDjmdContent(ctx, dc)
	}
	return c.InsertDjmdContent(ctx, dc)
}

// Upsert performs an upsert for DjmdContent.
func (c *Client) UpsertDjmdContent(ctx context.Context, dc *DjmdContent) error {
	db := c.db

	switch {
	case dc._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO djmdContent (` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $60, $61, $62, $63, $64, $65, $66, $67, $68, $69, $70, $71, $72, $73, $74, $75, $76, $77, $78` +
		`)` +
		` ON CONFLICT (ID) DO ` +
		`UPDATE SET ` +
		`FolderPath = EXCLUDED.FolderPath, FileNameL = EXCLUDED.FileNameL, FileNameS = EXCLUDED.FileNameS, Title = EXCLUDED.Title, ArtistID = EXCLUDED.ArtistID, AlbumID = EXCLUDED.AlbumID, GenreID = EXCLUDED.GenreID, BPM = EXCLUDED.BPM, Length = EXCLUDED.Length, TrackNo = EXCLUDED.TrackNo, BitRate = EXCLUDED.BitRate, BitDepth = EXCLUDED.BitDepth, Commnt = EXCLUDED.Commnt, FileType = EXCLUDED.FileType, Rating = EXCLUDED.Rating, ReleaseYear = EXCLUDED.ReleaseYear, RemixerID = EXCLUDED.RemixerID, LabelID = EXCLUDED.LabelID, OrgArtistID = EXCLUDED.OrgArtistID, KeyID = EXCLUDED.KeyID, StockDate = EXCLUDED.StockDate, ColorID = EXCLUDED.ColorID, DJPlayCount = EXCLUDED.DJPlayCount, ImagePath = EXCLUDED.ImagePath, MasterDBID = EXCLUDED.MasterDBID, MasterSongID = EXCLUDED.MasterSongID, AnalysisDataPath = EXCLUDED.AnalysisDataPath, SearchStr = EXCLUDED.SearchStr, FileSize = EXCLUDED.FileSize, DiscNo = EXCLUDED.DiscNo, ComposerID = EXCLUDED.ComposerID, Subtitle = EXCLUDED.Subtitle, SampleRate = EXCLUDED.SampleRate, DisableQuantize = EXCLUDED.DisableQuantize, Analysed = EXCLUDED.Analysed, ReleaseDate = EXCLUDED.ReleaseDate, DateCreated = EXCLUDED.DateCreated, ContentLink = EXCLUDED.ContentLink, Tag = EXCLUDED.Tag, ModifiedByRBM = EXCLUDED.ModifiedByRBM, HotCueAutoLoad = EXCLUDED.HotCueAutoLoad, DeliveryControl = EXCLUDED.DeliveryControl, DeliveryComment = EXCLUDED.DeliveryComment, CueUpdated = EXCLUDED.CueUpdated, AnalysisUpdated = EXCLUDED.AnalysisUpdated, TrackInfoUpdated = EXCLUDED.TrackInfoUpdated, Lyricist = EXCLUDED.Lyricist, ISRC = EXCLUDED.ISRC, SamplerTrackInfo = EXCLUDED.SamplerTrackInfo, SamplerPlayOffset = EXCLUDED.SamplerPlayOffset, SamplerGain = EXCLUDED.SamplerGain, VideoAssociate = EXCLUDED.VideoAssociate, LyricStatus = EXCLUDED.LyricStatus, ServiceID = EXCLUDED.ServiceID, OrgFolderPath = EXCLUDED.OrgFolderPath, Reserved1 = EXCLUDED.Reserved1, Reserved2 = EXCLUDED.Reserved2, Reserved3 = EXCLUDED.Reserved3, Reserved4 = EXCLUDED.Reserved4, ExtInfo = EXCLUDED.ExtInfo, rb_file_id = EXCLUDED.rb_file_id, DeviceID = EXCLUDED.DeviceID, rb_LocalFolderPath = EXCLUDED.rb_LocalFolderPath, SrcID = EXCLUDED.SrcID, SrcTitle = EXCLUDED.SrcTitle, SrcArtistName = EXCLUDED.SrcArtistName, SrcAlbumName = EXCLUDED.SrcAlbumName, SrcLength = EXCLUDED.SrcLength, UUID = EXCLUDED.UUID, rb_data_status = EXCLUDED.rb_data_status, rb_local_data_status = EXCLUDED.rb_local_data_status, rb_local_deleted = EXCLUDED.rb_local_deleted, rb_local_synced = EXCLUDED.rb_local_synced, usn = EXCLUDED.usn, rb_local_usn = EXCLUDED.rb_local_usn, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, dc.ID, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, dc.ID, dc.FolderPath, dc.FileNameL, dc.FileNameS, dc.Title, dc.ArtistID, dc.AlbumID, dc.GenreID, dc.BPM, dc.Length, dc.TrackNo, dc.BitRate, dc.BitDepth, dc.Commnt, dc.FileType, dc.Rating, dc.ReleaseYear, dc.RemixerID, dc.LabelID, dc.OrgArtistID, dc.KeyID, dc.StockDate, dc.ColorID, dc.DJPlayCount, dc.ImagePath, dc.MasterDBID, dc.MasterSongID, dc.AnalysisDataPath, dc.SearchStr, dc.FileSize, dc.DiscNo, dc.ComposerID, dc.Subtitle, dc.SampleRate, dc.DisableQuantize, dc.Analysed, dc.ReleaseDate, dc.DateCreated, dc.ContentLink, dc.Tag, dc.ModifiedByRBM, dc.HotCueAutoLoad, dc.DeliveryControl, dc.DeliveryComment, dc.CueUpdated, dc.AnalysisUpdated, dc.TrackInfoUpdated, dc.Lyricist, dc.ISRC, dc.SamplerTrackInfo, dc.SamplerPlayOffset, dc.SamplerGain, dc.VideoAssociate, dc.LyricStatus, dc.ServiceID, dc.OrgFolderPath, dc.Reserved1, dc.Reserved2, dc.Reserved3, dc.Reserved4, dc.ExtInfo, dc.RbFileID, dc.DeviceID, dc.RbLocalFolderPath, dc.SrcID, dc.SrcTitle, dc.SrcArtistName, dc.SrcAlbumName, dc.SrcLength, dc.UUID, dc.RbDataStatus, dc.RbLocalDataStatus, dc.RbLocalDeleted, dc.RbLocalSynced, dc.Usn, dc.RbLocalUsn, dc.CreatedAt, dc.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	dc._exists = true
	return nil
}

// Delete deletes the DjmdContent from the database.
func (c *Client) DeleteDjmdContent(ctx context.Context, dc *DjmdContent) error {
	db := c.db

	switch {
	case !dc._exists: // doesn't exist
		return nil
	case dc._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM djmdContent ` +
		`WHERE ID = $1`
	// run
	logf(sqlstr, dc.ID)
	if _, err := db.ExecContext(ctx, sqlstr, dc.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	dc._deleted = true
	return nil
}

func scanDjmdContentRows(rows *sql.Rows) ([]*DjmdContent, error) {
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}

	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

func (c *Client) AllDjmdContent(ctx context.Context) ([]*DjmdContent, error) {
	db := c.db

	const sqlstr = `SELECT * FROM DjmdContent`
	rows, err := db.QueryContext(ctx, sqlstr)
	if err != nil {
		return nil, logerror(err)
	}

	defer rows.Close()
	res, err := scanDjmdContentRows(rows)
	if err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByAlbumID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__album_i_d'.
func (c *Client) DjmdContentByAlbumID(ctx context.Context, albumID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByAlbumID(ctx context.Context, db DB, albumID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE AlbumID = $1`
	// run
	logf(sqlstr, albumID)
	rows, err := db.QueryContext(ctx, sqlstr, albumID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByArtistID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__artist_i_d'.
func (c *Client) DjmdContentByArtistID(ctx context.Context, artistID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByArtistID(ctx context.Context, db DB, artistID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE ArtistID = $1`
	// run
	logf(sqlstr, artistID)
	rows, err := db.QueryContext(ctx, sqlstr, artistID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByComposerID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__composer_i_d'.
func (c *Client) DjmdContentByComposerID(ctx context.Context, composerID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByComposerID(ctx context.Context, db DB, composerID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE ComposerID = $1`
	// run
	logf(sqlstr, composerID)
	rows, err := db.QueryContext(ctx, sqlstr, composerID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByGenreID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__genre_i_d'.
func (c *Client) DjmdContentByGenreID(ctx context.Context, genreID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByGenreID(ctx context.Context, db DB, genreID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE GenreID = $1`
	// run
	logf(sqlstr, genreID)
	rows, err := db.QueryContext(ctx, sqlstr, genreID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByKeyID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__key_i_d'.
func (c *Client) DjmdContentByKeyID(ctx context.Context, keyID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByKeyID(ctx context.Context, db DB, keyID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE KeyID = $1`
	// run
	logf(sqlstr, keyID)
	rows, err := db.QueryContext(ctx, sqlstr, keyID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByLabelID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__label_i_d'.
func (c *Client) DjmdContentByLabelID(ctx context.Context, labelID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByLabelID(ctx context.Context, db DB, labelID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE LabelID = $1`
	// run
	logf(sqlstr, labelID)
	rows, err := db.QueryContext(ctx, sqlstr, labelID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByMasterDBIDMasterSongID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__master_d_b_i_d__master_song_i_d'.
func (c *Client) DjmdContentByMasterDBIDMasterSongID(ctx context.Context, masterDBID, masterSongID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByMasterDBIDMasterSongID(ctx context.Context, db DB, masterDBID sql.NullString, masterSongID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE MasterDBID = $1 AND MasterSongID = $2`
	// run
	logf(sqlstr, masterDBID, masterSongID)
	rows, err := db.QueryContext(ctx, sqlstr, masterDBID, masterSongID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByOrgArtistID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__org_artist_i_d'.
func (c *Client) DjmdContentByOrgArtistID(ctx context.Context, orgArtistID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByOrgArtistID(ctx context.Context, db DB, orgArtistID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE OrgArtistID = $1`
	// run
	logf(sqlstr, orgArtistID)
	rows, err := db.QueryContext(ctx, sqlstr, orgArtistID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRemixerID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__remixer_i_d'.
func (c *Client) DjmdContentByRemixerID(ctx context.Context, remixerID sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByRemixerID(ctx context.Context, db DB, remixerID sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE RemixerID = $1`
	// run
	logf(sqlstr, remixerID)
	rows, err := db.QueryContext(ctx, sqlstr, remixerID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByUUID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content__u_u_i_d'.
func (c *Client) DjmdContentByUUID(ctx context.Context, uuid sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByUUID(ctx context.Context, db DB, uuid sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE UUID = $1`
	// run
	logf(sqlstr, uuid)
	rows, err := db.QueryContext(ctx, sqlstr, uuid)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbDataStatus retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_data_status'.
func (c *Client) DjmdContentByRbDataStatus(ctx context.Context, rbDataStatus sql.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbDataStatus(ctx context.Context, db DB, rbDataStatus sql.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_data_status = $1`
	// run
	logf(sqlstr, rbDataStatus)
	rows, err := db.QueryContext(ctx, sqlstr, rbDataStatus)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDataStatus retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_data_status'.
func (c *Client) DjmdContentByRbLocalDataStatus(ctx context.Context, rbLocalDataStatus sql.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDataStatus(ctx context.Context, db DB, rbLocalDataStatus sql.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_data_status = $1`
	// run
	logf(sqlstr, rbLocalDataStatus)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDataStatus)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDeleted retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_deleted'.
func (c *Client) DjmdContentByRbLocalDeleted(ctx context.Context, rbLocalDeleted sql.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDeleted(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_deleted = $1`
	// run
	logf(sqlstr, rbLocalDeleted)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDeletedBitDepth retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_deleted__bit_depth'.
func (c *Client) DjmdContentByRbLocalDeletedBitDepth(ctx context.Context, rbLocalDeleted, bitDepth sql.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDeletedBitDepth(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64, bitDepth sql.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_deleted = $1 AND BitDepth = $2`
	// run
	logf(sqlstr, rbLocalDeleted, bitDepth)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted, bitDepth)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDeletedBitRate retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_deleted__bit_rate'.
func (c *Client) DjmdContentByRbLocalDeletedBitRate(ctx context.Context, rbLocalDeleted, bitRate sql.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDeletedBitRate(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64, bitRate sql.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_deleted = $1 AND BitRate = $2`
	// run
	logf(sqlstr, rbLocalDeleted, bitRate)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted, bitRate)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDeletedFileType retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_deleted__file_type'.
func (c *Client) DjmdContentByRbLocalDeletedFileType(ctx context.Context, rbLocalDeleted, fileType sql.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDeletedFileType(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64, fileType sql.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_deleted = $1 AND FileType = $2`
	// run
	logf(sqlstr, rbLocalDeleted, fileType)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted, fileType)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalDeletedServiceID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_deleted__service_i_d'.
func (c *Client) DjmdContentByRbLocalDeletedServiceID(ctx context.Context, rbLocalDeleted, serviceID sql.NullInt64) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalDeletedServiceID(ctx context.Context, db DB, rbLocalDeleted sql.NullInt64, serviceID sql.NullInt64) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_deleted = $1 AND ServiceID = $2`
	// run
	logf(sqlstr, rbLocalDeleted, serviceID)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalDeleted, serviceID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByRbLocalUsnID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'djmd_content_rb_local_usn__i_d'.
func (c *Client) DjmdContentByRbLocalUsnID(ctx context.Context, rbLocalUsn sql.NullInt64, id sql.NullString) ([]*DjmdContent, error) {
	// func DjmdContentByRbLocalUsnID(ctx context.Context, db DB, rbLocalUsn sql.NullInt64, id sql.NullString) ([]*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE rb_local_usn = $1 AND ID = $2`
	// run
	logf(sqlstr, rbLocalUsn, id)
	rows, err := db.QueryContext(ctx, sqlstr, rbLocalUsn, id)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*DjmdContent
	for rows.Next() {
		dc := DjmdContent{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dc)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdContentByID retrieves a row from 'djmdContent' as a DjmdContent.
//
// Generated from index 'sqlite_autoindex_djmdContent_1'.
func (c *Client) DjmdContentByID(ctx context.Context, id sql.NullString) (*DjmdContent, error) {
	// func DjmdContentByID(ctx context.Context, db DB, id sql.NullString) (*DjmdContent, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, FolderPath, FileNameL, FileNameS, Title, ArtistID, AlbumID, GenreID, BPM, Length, TrackNo, BitRate, BitDepth, Commnt, FileType, Rating, ReleaseYear, RemixerID, LabelID, OrgArtistID, KeyID, StockDate, ColorID, DJPlayCount, ImagePath, MasterDBID, MasterSongID, AnalysisDataPath, SearchStr, FileSize, DiscNo, ComposerID, Subtitle, SampleRate, DisableQuantize, Analysed, ReleaseDate, DateCreated, ContentLink, Tag, ModifiedByRBM, HotCueAutoLoad, DeliveryControl, DeliveryComment, CueUpdated, AnalysisUpdated, TrackInfoUpdated, Lyricist, ISRC, SamplerTrackInfo, SamplerPlayOffset, SamplerGain, VideoAssociate, LyricStatus, ServiceID, OrgFolderPath, Reserved1, Reserved2, Reserved3, Reserved4, ExtInfo, rb_file_id, DeviceID, rb_LocalFolderPath, SrcID, SrcTitle, SrcArtistName, SrcAlbumName, SrcLength, UUID, rb_data_status, rb_local_data_status, rb_local_deleted, rb_local_synced, usn, rb_local_usn, created_at, updated_at ` +
		`FROM djmdContent ` +
		`WHERE ID = $1`
	// run
	logf(sqlstr, id)
	dc := DjmdContent{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&dc.ID, &dc.FolderPath, &dc.FileNameL, &dc.FileNameS, &dc.Title, &dc.ArtistID, &dc.AlbumID, &dc.GenreID, &dc.BPM, &dc.Length, &dc.TrackNo, &dc.BitRate, &dc.BitDepth, &dc.Commnt, &dc.FileType, &dc.Rating, &dc.ReleaseYear, &dc.RemixerID, &dc.LabelID, &dc.OrgArtistID, &dc.KeyID, &dc.StockDate, &dc.ColorID, &dc.DJPlayCount, &dc.ImagePath, &dc.MasterDBID, &dc.MasterSongID, &dc.AnalysisDataPath, &dc.SearchStr, &dc.FileSize, &dc.DiscNo, &dc.ComposerID, &dc.Subtitle, &dc.SampleRate, &dc.DisableQuantize, &dc.Analysed, &dc.ReleaseDate, &dc.DateCreated, &dc.ContentLink, &dc.Tag, &dc.ModifiedByRBM, &dc.HotCueAutoLoad, &dc.DeliveryControl, &dc.DeliveryComment, &dc.CueUpdated, &dc.AnalysisUpdated, &dc.TrackInfoUpdated, &dc.Lyricist, &dc.ISRC, &dc.SamplerTrackInfo, &dc.SamplerPlayOffset, &dc.SamplerGain, &dc.VideoAssociate, &dc.LyricStatus, &dc.ServiceID, &dc.OrgFolderPath, &dc.Reserved1, &dc.Reserved2, &dc.Reserved3, &dc.Reserved4, &dc.ExtInfo, &dc.RbFileID, &dc.DeviceID, &dc.RbLocalFolderPath, &dc.SrcID, &dc.SrcTitle, &dc.SrcArtistName, &dc.SrcAlbumName, &dc.SrcLength, &dc.UUID, &dc.RbDataStatus, &dc.RbLocalDataStatus, &dc.RbLocalDeleted, &dc.RbLocalSynced, &dc.Usn, &dc.RbLocalUsn, &dc.CreatedAt, &dc.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &dc, nil
}
